# 数据结构

什么是数据结构?
简单来讲数据结构就是是计算机中存储、组织数据的一种方式,就像我们该的楼房,楼房也有自己的结构---钢筋混凝土以及力学

简单分析一下数据结构-----
他具有一定逻辑关系，应用了某种存储结构，并且封装了相应操作的数据元素集合。

> 数据结构主要有一下几种
> 栈（Stack）：特殊的线性表.
> 队列（Queue）：也是一种特殊的线性表。和栈不同的是，
> 数组（Array）：数组是一种聚合数据类型.
> 链表（Linked List）：非连续的存储.
> 树（Tree）：非线性结构，例如二叉树
> 图（Graph）：图是另一种非线性数据结构.
> 堆（Heap）：特殊的树形数据结构.
> 散列表（Hash table）等

不同种类的数据结构适合于不同种类的应用,如栈,先进后出,队列,只能在两头添加或者删除

1.线性表
线性表：零个或者多个数据元素的有限序列。

性质：

数据元素可以为空
数据元素有限
数据元素之间的逻辑结构为线性结构，也就是一对一的关系
数据元素类型相同---最常见的是数组

> 线性表可以分为两种： 顺序线性表 链式线性表

顺序线性表：使用一段连续的地址存储单元放置线性表的数据元素。

> 顺序线性表的优缺点： 优点：
>
> - 可以快速根据下标来获取数据元素，时间复杂度为O(1)
> - 逻辑关系是一对一的关系，连续存储单元足以储存，不需要增加额外的存储空间
>
> 缺点：
>
> - 插入和删除操作需要移动大量的元素，时间复杂度为O(n)
> - 线性表的存储空间大小难以确定，并且不好扩展
> - 造成存储空间碎片

![1642861966215](C:\Users\Gavin\AppData\Local\Temp\1642861966215.png)

链式线性表
链式线性表：线性表的数据元素可以存储在任意的存储单元，每一个单元不仅要包括数据也要把总括数据的地址(单向链表存一个地址,双向链表要存两个)

链式（单向链表）和顺序线性表优缺点对比：

存储分配方式：

- 顺序 -> 一段地址连续的存储空间
- 链式 -> 任意地址存储空间

时间复杂度：

- 查找
  顺序 -> O(1)
  链式 -> O(n)
- 插入和删除
  顺序 -> O(n)
  链式 -> 寻找相应的节点，时间复杂度为O(n)，然后，插入和删除为O(1)

空间复杂度：

- 顺序 -> 需要提前就要分配存储空间，分配大了，浪费空间，分配小了，容易发生上溢
- 链式 -> 不需要提前分配空间，只要有存储空间分配就行，数据元素个数只受可分配存储空间大小的限制

> ***顺序结构与链式结构优缺点解读----***
>
> 顺序结构可以直接通过下表来查找数据,可以很快定位数据所在位置, 而链式结构需要从头开始,一个一个查找,自然效率慢了;
>
> 顺序结构增加或者删除数据,要增加或者删除的位置后的其他元素都要进行移动才能保正空间的紧密型;
>
> 链式结构空间上不连续,增加删除元素只需要修改增加或者删除元素前后的数据即可,效率肯定比顺序结构高
>
> 链式结构查找数据要从头开始根据地址一个一个查找元素;

总结---
1,如果对数据增删操作不多,或者仅仅是查数据,那么就适合用顺序结构,
否则建议链式结构;
2,如果知道线性表需要的存储空间，可以使用顺序结构；
如果不知道要多大的存储空间，则使用链式存储结构。



什么是数据结构？

数据结构是计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。

常见的数据结构
线性表----
线性表中又分为紧密结构和跳转结构

紧密结构-----代表----->>数组

![在这里插入图片描述](https://img-blog.csdnimg.cn/239206aa1a1d444d91c31d2eca1e41bb.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAR2F2aW5fTGlt,size_20,color_FFFFFF,t_70,g_se,x_16)
跳转结构-----代表---->>>链表

![在这里插入图片描述](https://img-blog.csdnimg.cn/bdd25e3cd8be409dbf6feaeb0c57264d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAR2F2aW5fTGlt,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)
为什么会出现那么多的数据结构---什么hashset,hashmap tree等,首先我们分析一下------>
数组这种紧密结构存储数据时的特点------>>>>

1,数组一旦声明了大小也随即确定了,有时候遇到一些不确定数量的数据存储就比较麻烦;
2,删除和添加元素效率低;
3,数组中存储的数据 可重复,对于不可重复的数据没法做出筛选使其满足;

数组中提供的方法比较少,不如集合中的多;集合中的内容放在这篇文章中了,不在赘述;

[浅谈java中容器的发展史之collection接口](https://blog.csdn.net/weixin_54061333/article/details/121002129)

## JAVA中数组

### 二维数组

```java
package com.array.sort;

/**
 * @Auther: GavinLim
 * @Date: 2021/6/27 - 06 - 29 - 15:12
 * @Description: com.array.sort
 * @version: 1.0
 */
public class Kuaijiejian {

    public static void main(String[] args) {
        int[][] array = new int[3][];
        array[0]= new int[]{0, 1, 2, 3, 4, 5};
        array[1]= new int[]{6,7,8};
        array[2]=new int[]{9};
        //二维数组的遍历方式--
        //双重普通for
        for (int i = 0; i <array.length ; i++) {//得到的是一个数组，再将数组进行遍历，
            for (int j = 0; j < array[i].length; j++) {
                System.out.print(array[i][j]+"\t");
            }
            System.out.println();
        }
        //普通for+增强for
        for (int i = 0; i <array.length ; i++) {//得到的是一个数组，再将数组进行遍历，
            for (int j:array[i]
                 ) {
                System.out.print(j+"\t");
            }
            System.out.println();
        }
        //增强for 与增强for
        for (int [] i:array //
             ) {
            for (int a:i
                 ) {

            }
            System.out.println();
        }
        //增强for与普通for
        for (int [] arr:array
        ) {
            for (int j = 0; j <arr.length ; j++) {
                System.out.print(arr[j]+"\t");
            }
            System.out.println();
        }
    }

}

```

本代码主要用到了for循环，过多的也不做解释，
只是要注意一点，for循环中每一个数组不能为空，因为都吊用了数组的长度 .length，如果数组为空，会出现空指向异常的问题，
举个例子--

```java
/**
 * @Auther: GavinLim
 * @Date: 2021/6/27 - 06 - 29 - 15:12
 * @Description: com.array.sort
 * @version: 1.0
 */
public class Kuaijiejian {

    public static void main(String[] args) {
        int[][] array = new int[4][];
        array[0]= new int[]{0, 1, 2, 3, 4, 5};
        array[1]= new int[]{6,7,8};
        array[2]=new int[]{9};
        //二维数组的遍历方式--

        //增强for 与增强for
        for (int [] i:array //
             ) {
            for (int a:i
                 ) {

            }
            System.out.println();
        }

    }

}

```

```bash
Picked up JAVA_TOOL_OPTIONS: -Dfile.encoding=UTF-8
Exception in thread "main" java.lang.NullPointerException: Cannot read the array length because "<local6>" is null
	at com.array.sort.Kuaijiejian.main(Kuaijiejian.java:21)
```

其他：增强for循环的实现是用迭代器完成的，感兴趣的可以自己去看源码来理解；
下面来画个内存吧--
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210629175315512.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81NDA2MTMzMw==,size_16,color_FFFFFF,t_70)三维数组多维数组也一样，实际上在java中可以把多维数组看成一维数组。这样在循环遍历的时候也好容易理解；



### 数组的遍历与冒泡排序

> 排序是一种思想，java中常见的排序方法有很多，常见的排序方法有：冒泡排序、快速排序、选择排序、插入排序、希尔排序，甚至还有基数排序、鸡尾酒排序、桶排序、鸽巢排序、归并排序等。
> 今天抽空将每一种排序方式进行复习，同时总结一下之前学过的内容；

```java
/*按照惯例先复习*/
package com.array.sort;
public class SortArrayMethod {
    //数组的初始化
    //数组的默认初始化，在定义时候各元素就有默认值
    int array0[] = new int[9];
    //数组静态初始化
    int array[] = {12, 45, 85, 213, 1, 85, 47, 71};
    //数组的动态初始化
    //开始的时候只定义不分配空间，
    int arrays[];
    public void test() {
        //需要的时候再分配空间--然后赋予值
        arrays = new int[2];
        arrays[0] = 1;
        arrays[1] = 2;
    }
    //定义排序方法--可以将常用的方法整理成一个=合集以便日常工作中拿来直接用，提高工作效率--好主意
    public void sortArray(int array[]) {//定义方法--对数组进行排序
       //冒泡排序法--简介
        /*
        冒泡排序：冒泡排序（Bubble Sort），
        是一种计算机科学领域的较简单的排序算法。
        它重复地走访过要排序的数列，一次比较两个元素，
        如果他们的顺序错误就把他们交换过来。走
        访数列的工作是重复地进行直到没有再需要交换，
        也就是说该数列已经排序完成。
        这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端。
         */
        //开始比较
        for (int i = 0; i < array.length - 1; i++) {//
            for (int j = 0; j < array.length - 1 - i; j++) {
                //第一个跟第二个进行比较，如果第二个＞第一个。则第二个跟第一个交换位置，同理第二个跟第三个。。。
                if (array[j] < array[j + 1]) {
                    int temp = array[j];
                    array[j] = array[j + 1];
                    array[j + 1] = temp;
                    //交换位置了
                }
            }
        }
    }
}
/*实际上根据此种思想有很多衍生版本，只要思想有了，方法就有了*/
```

```java
package com.array.sort;
import java.util.Arrays;
public class SortArray {
    public static void main(String[] args) {
        int array[] = {12, 45, 85, 213, 1, 85, 47, 71};
        //数组的排序方式
        //第一种--//冒泡排序--降序排序(也可以换成升序)
        new SortArrayMethod().sortArray(array);
        //验证是否排序成功
        for (int i = 0; i < array.length; i++) {
            System.out.print(array[i] + "\t");
        }
        System.out.println();
        //实际上不用这么复杂，直接调用Arrays.sort()即可升序排序
        Arrays.sort(array);
        for (int ele:array)//foreach参数--迭代的下标，要迭代的内容
            System.out.print(ele+"\t");//如果只有一行代码可以省略{}

    }
}

```

![在这里插入图片描述](https://img-blog.csdnimg.cn/2021062616434228.png)

> 像冒泡排序基本用不到，但它是入门必备的基础，任何其他的算法也是由此展开而来的--至少是思想；

### 数组的遍历与快速排序

> 话不多说，直接看东西---

```java
package com.fast;
import java.util.Arrays;
/**
 * @Auther: GavinLim
 * @Date: 2021/6/26 - 06 - 26 - 16:55
 * @Description: com.fast
 * @version: 1.0
 */
public class FastSort {
    public static void main(String[] args) {
        int a[] = {12, -14, 2, 5, 45, -7, 5, 41};
         quickSort(a,0,a.length-1);
        System.out.println(Arrays.toString(a));
    }
    /**
     * --段落注释
     * 快速排序
     * <p>
     * 从数列中挑出一个元素，称为“基准”
     * 重新排序数列，所有元素比基准值小的摆放在基准前面，
     * 所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。
     * 在这个分割之后，该基准是它的最后位置。这个称为分割（partition）操作。
     * 递归地把小于基准值元素的子数列和大于基准值元素的子数列排序。
     */
    //快速排序前的准备工作--知道该方法的用法(start 为 0，end为数组的长度-1)
    public static void quickSort(int array[], int start, int end) {
        //传入参数时候要判断是否符合要求
        if(start>end) {
           return;//结束方法
        }
        int i = start;//定义基准值，以0作为基准值--因为要做到通用
        int base = array[i];//找到基准值作为比较的对象end=array.length-1;//
        int j = end;//
        //
        //开始比较，因为要重复遍历，所以要设置一个循环，当满足条件时退出循环，所以选择while
        while (i<j){
            //从右向左遍历--先从右向左遍历找到小于基准值的数，
            /*解析--当从右向左遍历直到找到小于base的，然后在执行下面的操作，
            以上述数组为例--
            第一块 执行循环--》    j=7,i=0;--->a[7]=41大于基准值12;
                         j--;     --> j=6, i=0;
                         j=6,i=0;--->a[6] =5小于基准值12;跳出循环
                  第二块--》       执行if语句
               将找到的比基准值小的赋值给a[0];此时数组的内容为5, -14, 2, 5, 45, -7,5 , 41
               再将基准值赋值给a[6]，此时数组的内容为5, -14, 2, 5, 45, -7,12 , 41
                  j=6,i=0;
    第三块 执行另一个循环  --》  从左向右遍历，找到比基准值大的,此时基准值仍然为a[0]=12;
                 i++;
                直到找到a[4]=45>基准值12，然后跳出循环，-->i=4,j=6
                第四块--》 执行if语句
           将找到的比基准值大的复制给a[6]    此时数组的内容为5, -14, 2, 5, 45, -7,45 , 41
           再将基准值付给a[4]此时数组的内容为5, -14, 2, 5, 12, -7,45 , 41
           第一次操作是给出划分，
以基准值12所在的位置进行划分，以便将大于基准值的放在它右边，小于的放在它左边（等于的话自己可以根据喜好进行放置--）
递归调用 将4之前的部分重新进行排序，quickSort(array,0,3);

将4之后的也如法炮制quickSort(array,5,7);


             */
            while(array[j]>=base&&j>i){
                j--;
            }
            //找到比base小的数，然后将它赋值给基准值
            if(j>i){
                //将大的数复制给基准值右边的数
                // 第一次循环时候这里i++的值仍然为初始值
                array[i++]=array[j];
                array[j]=base;
            }
            while(array[i]<base&&j>i){
                i++;
            }
            if (j>i){
                array[j--]=array[i];
                array[i]=base;
            }

            quickSort(array,start,i-1);
            quickSort(array,i+1,end);
        }

    }
}
```

在此回顾一下三目运算符
先看三目运算符
对于有些只有两个选项的选择分支结构,可以使用三目运算符来代替. 如:

```java
if(a<b)
    min=a;
else
    min=b;
```

可以用下面的条件运算符来处理
min=(a<b)?a:b;
　　其中"(a<b)?a:b"是一个"条件表达式",它是这样执行的:　　如果a<b为真,则表达式取a值,否则取b值.

　　条件运算符由两个符号组成"?"和":", 要求有3个操作对象,所以也叫它三目运算符,它是C语言中唯一的三目运算符.

　　　　它的一般形式为:

　　　　　　　　表达式1?表达式2:表达式3;
　　　　　　　　上代码--
　　　　　　　　
以下两种方式执行的逻辑是一样的；

```java
package com.ter;

import com.sun.tools.javac.Main;

/**
 * @Auther: GavinLim
 * @Date: 2021/6/27 - 06 - 27 - 10:14
 * @Description: com.ter
 * @version: 1.0
 */
public class max {
    public static void main(String[] args) {
        int arr[]={12,14,-45,454,0,6,7,9,-2565};
        int max=arr[0];
        int max1=arr[1];
        for (int i=0;i<arr.length;i++){
            max=arr[i]<max?max:arr[i];
        }
        System.out.println(max);
        for (int i=0;i<arr.length;i++){
            if(arr[i]>max1){
                max1=arr[i];
            }
        }
        System.out.println(max1);
    }
}

```

习惯养成---将常见的一些代码整理成方法，以便后续会用到，这比自己再去写以便效率要高多了；

```java
package com.ter;


/**
 * @Auther: GavinLim
 * @Date: 2021/6/27 - 06 - 27 - 10:14
 * @Description: com.ter
 * @version: 1.0
 */
public class Max {
    public static void main(String[] args) {
        int array[] = {12, 14, -45, 454, 0, 6, 7, 9, -2565};

        int max = getMax(array);
        System.out.println(max);
    }

    public static int getMax(int array[]) {
        int max = array[0];
        for (int i = 0; i < array.length; i++) {
            if (array[i] > max) {
                max = array[i];
            }
        }
        return max;
    }

}

```

日拱一卒，只能前进；
补充一个小游戏吧---

```java
package com.gavin.exercise;

import java.util.Scanner;

/**
 * @author : Gavin
 * @date: 2021/6/28 - 06 - 28 - 10:03
 * @Description: com.gavin.exercise
 * @version: 1.0
 */
public class Contral {
    public static void main(String[] args) {
        //实现功能：男孩女孩选择晚饭吃什么，如果意见一致，听男生的，如果意见不一致，听女生的
        Scanner scanner= new Scanner(System.in);
        System.out.println("今晚吃什么？-1，鱼香肉丝-2，宫保鸡丁,-3麻辣小龙虾");
        System.out.println("请男生选择--");
        int boyChoice=scanner.nextInt();
        while(!(boyChoice==1|boyChoice==2|boyChoice==3)){
            System.out.println("请重新输入--");
            boyChoice=scanner.nextInt();
        }
        System.out.println("请女生选择--");
        int girlChoice=scanner.nextInt();
        while(!(girlChoice==1|girlChoice==2|girlChoice==3)){
            System.out.println("请重新输入--");
            girlChoice=scanner.nextInt();
        }
        String str=boyChoice==girlChoice?"听男生的":"听女生的";
        System.out.println(str);
        scanner.close();
    }
}

```



## JAVA中的集合

集合中可以存放任意类型的数据吗?

今天我来试一下--

```java
class Person{
    String name;
    int age;
    public Person(String name,int age){
        this.name=name;
        this.age=age;
    }

}

public class Test {
    public static void main(String args[]) {

        Collection col = new ArrayList();
        col.add(3);
        List list = new ArrayList<Integer>();
        List list1= Arrays.asList(new Integer[]{12,12,122,2133});
        list.add(1236789);//集合中可以存放任意类型的数据.如果不指定类型

        col.add(list);
        col.addAll(list1);
        Person person = new Person("张三",18);
        col.add(person);
        System.out.println(col.toString());

    }
}
```

```java
Picked up JAVA_TOOL_OPTIONS: -Dfile.encoding=UTF-8
[3, [1236789], 12, 12, 122, 2133, baozhuang.Person@4f023edb]
```

可以看到确实可以存放任意类型数据,前提是没有限定数的存储类型--如果指定了数据类型----如下
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210714132607920.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81NDA2MTMzMw==,size_16,color_FFFFFF,t_70)
就会报错;

其他常用方法---

```java
class Person {
    String name;
    int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

}

public class Test {
    public static void main(String args[]) {

        Collection col = new ArrayList();
        col.add(3);
        List list = new ArrayList<Integer>();
        List list1 = Arrays.asList(new Integer[]{12, 12, 122, 2133});
        list.add(1236789);//集合中可以存放任意类型的数据.如果不指定类型

        col.add(list);
        col.addAll(list1);
        Person person = new Person("张三", 18);
        col.add(person);
        System.out.println(col.toString());
        col.remove(person);//移除person对象
        System.out.println(col.toString());
        col.clear();//清除所有元素
        int size = col.size();//集合大小
        boolean empty = col.isEmpty();//判断按集合是否为空
        System.out.println(empty);
        System.out.println(size);
        System.out.println(col.toString());


        Collection col1= new ArrayList();
        Collection col2= new ArrayList();
        col1.add(new Integer(1));
        col2.add(1);
        boolean aaa=col1.cotains(1);
        boolean equals = col1.equals(col2);
        System.out.println(equals);
        System.out.println(col1==col2);
        System.out.println(aaa);
    }
}
```

```java
class Person {
    String name;
    int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

}

public class Test {
    public static void main(String args[]) {

       Collection col= new ArrayList();
       col.add(new Person("二狗子",18));
       col.add(1);
       col.add('A');
       col.add("Hello");
//遍历方式1----
        for (Object o:col
             ) {
            System.out.println(o);

        }
        //遍历方式二
        Iterator iterator = col.iterator();
while (iterator.hasNext()){
    System.out.println(iterator.next()+"\t");
}
    }
}
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210714140151745.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81NDA2MTMzMw==,size_16,color_FFFFFF,t_70)
 Iterator 迭代的方式----通过移动指针的方式如果有下一位元素,则继续迭代,否则 退出该循环--原理图
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210714140442901.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81NDA2MTMzMw==,size_16,color_FFFFFF,t_70)

**为啥父类和子类都要实现List<E>接口?**

```java
public class ArrayList<E> extends AbstractList<E>
        implements List<E>, RandomAccess, Cloneable, java.io.Serializable
{
```

```java
public abstract class AbstractList<E> extends AbstractCollection<E> implements List<E> {
    /**
     * Sole constructor.  (For invocation by subclass constructors, typically
     * implicit.)
     */
    protected AbstractList() {
    }

```

这样的好处是什么?
没必要吧!!!!!!历史原因而已.

### ArryList

```java
public class Test {
    public static void main(String args[]) {
      //集合的开辟方式
        Collection aaaa= new ArrayList();//接口=实现类
        List list1= new ArrayList();//接口=实现类
        ArrayList arrayList= new ArrayList();//实现类=实现类
    }
}
```

最好是用接口=实现类来开辟,因为容易维护,修改数据结构也方便

```java
public class Test {
    public static void main(String args[]) {
      //集合的开辟方式
        Collection aaaa= new ArrayList();//接口=实现类
        List list1= new ArrayList();//接口=实现类
        ArrayList arrayList= new ArrayList();//实现类=实现类
         aaaa= new LinkedList();
    }
}
```

下面看一下ArrayList的实现源码
继承和实现类如下:

> public class ArrayList<E> extends AbstractList<E>
>         implements List<E>, RandomAccess, Cloneable, java.io.Serializable

里面有几个重要的参数---
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210714160201120.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81NDA2MTMzMw==,size_16,color_FFFFFF,t_70)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210714160248333.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81NDA2MTMzMw==,size_16,color_FFFFFF,t_70) 
底层使用Object 数组来接收数据--

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210714160944962.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81NDA2MTMzMw==,size_16,color_FFFFFF,t_70)从JDK1.8开始    默认的创建的底层数组大小为空,当我们添加数据的时候才开始创建一个大小为10 的空间,如果空间不够的话,扩容,然后旧数组的内容拷贝到新数组;

### Arraylist与Vectord的区别

> 实际上随着JDK版本的不断更新,性能上会有所改进,于是乎一些老的接口或者方法会逐渐被抛弃,但并不是不能使用,知识不在提倡使用;
> 今天我们一起来看一下ArrayList与Vector 的区别

按照惯例的话,先来后到,先看Vector(JDK15)

Vector继承了实现了AbstractList,实现了List, RandomAccess, Cloneable, java.io.Serializable

```java
public class Test {
    public static void main(String args[]) {

        Vector v= new Vector();
        v.add(123);
        boolean add = v.add("abc");


    }
}
```

> Vector中的属性 
>  protected Object[] elementData;  //说明底层也是Object数组
>  protected int elementCount;   
> protected int capacityIncrement;



调用构造方法---

```java
 public Vector() {
        this(10);
    }
```

无参构造去调用了有参构造,传入参数为10

```java
 public Vector(int initialCapacity) {
        this(initialCapacity, 0);
    }

```

初始化为容量为10的数组,增长幅度为0
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210714170550346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81NDA2MTMzMw==,size_16,color_FFFFFF,t_70)



接着往里面添加元素

```java
 public synchronized boolean add(E e) {
        modCount++;
        add(e, elementData, elementCount);
        return true;
    }
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210714171701411.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81NDA2MTMzMw==,size_16,color_FFFFFF,t_70)

```java
private void add(E e, Object[] elementData, int s) {
        if (s == elementData.length)
            elementData = grow();
        elementData[s] = e;
        elementCount = s + 1;
    }
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210714171923715.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81NDA2MTMzMw==,size_16,color_FFFFFF,t_70)
一开始s(即初始的elementCount)小于数组的长度10的,所以elementData[1]=123;
然后 elementCount = s + 1;
随着元素的添加,当s == elementData.length,时就要开始扩容了;

```java
 private Object[] grow() {
        return grow(elementCount + 1);
    }

```

```java
private Object[] grow(int minCapacity) {
        int oldCapacity = elementData.length;
        int newCapacity = ArraysSupport.newLength(oldCapacity,
                minCapacity - oldCapacity, /* minimum growth */
                capacityIncrement > 0 ? capacityIncrement : oldCapacity
                                           /* preferred growth */);
        return elementData = Arrays.copyOf(elementData, newCapacity);
    }
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210714172735520.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81NDA2MTMzMw==,size_16,color_FFFFFF,t_70)这里也可以看出Vector扩容后的容量是原来的两倍

```java
public static int newLength(int oldLength, int minGrowth, int prefGrowth) {
        // assert oldLength >= 0
        // assert minGrowth > 0

        int newLength = Math.max(minGrowth, prefGrowth) + oldLength;
        if (newLength - MAX_ARRAY_LENGTH <= 0) {
            return newLength;
        }
        return hugeLength(oldLength, minGrowth);
    }
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210714173345473.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81NDA2MTMzMw==,size_16,color_FFFFFF,t_70)一般是走不到return Integer.MAX_VALUE;这一步的
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210714173445687.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81NDA2MTMzMw==,size_16,color_FFFFFF,t_70)所以Vector的底层依旧是Object数组,但是Vector时线程安全的;

再来看ArrayList-----(JDK15)

```java
public class Test {
    public static void main(String args[]) {

        Vector v= new Vector();
        v.add("abc");
        boolean add = v.add(123);
ArrayList list= new ArrayList();
list.add("abc");

    }
}
```

先看ArrayList中的属性---(JDK15)

> ***private static final int DEFAULT_CAPACITY = 10;*** 

> ***private static final Object[] EMPTY_ELEMENTDATA = {};***  

> ***private static final Object[]DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};***   

> ***transient Object[] elementData;***

> ***private int size;***

调用无参构造---

```java
public ArrayList() {
        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
    }
```

这里默认时开辟空间大小的0 的一个Object数组,

![在这里插入图片描述](https://img-blog.csdnimg.cn/2021071420294946.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81NDA2MTMzMw==,size_16,color_FFFFFF,t_70#pic_center)
注释表明在第一次添加元素后才确定数组空间大小

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210714203214504.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81NDA2MTMzMw==,size_16,color_FFFFFF,t_70)具体源码--请看JDK1.8之前的版本
这里只说一下   底层也是Object数组,默认开辟大小为16的空间然后如果空间不够,也是要扩容的;

添加元素--
public boolean add(E e) {
        modCount++;
        add(e, elementData, size);
        return true;
    }

方法跟Vector一样,不在赘述;



> ***Arraylist与Vector的区别---*** 

> 1,线程安全---Vector,效率比Arraylist低;
> 2,Vector数据增长为100%,而ArrayList为50%
> 3,如果涉及到查询\修改等的效率,不考虑安全性问题,那么优先考虑ArrayList,如果涉及到堆栈操作,考虑Vector





### Linkedlist

```java
package baozhuang;

import java.util.Iterator;
import java.util.LinkedList;
import java.util.ListIterator;

/**
 * @author : Gavin
 * @date: 2021/7/15 - 07 - 15 - 19:40
 * @Description: baozhuang
 * @version: 1.0
 */
public class Today {
    public static void main(String[] args) {
        LinkedList <String>list = new LinkedList();
        list.add("aaaa");
        list.add("bbbb");
        list.add("cccc");
        list.add("dddd");
        list.add("eeee");
        
        list.add(2,"qwer");
        list.addFirst("1111");
        list.addLast("2222");
        list.push("hahaha");//压栈
        String peek = list.peek();
        System.out.println(peek);//返回第一个元素
        /*public E peek() {
            final LinkedList.Node<E> f = first;
            return (f == null) ? null : f.item;
        }
        */

        System.out.println(list.element());//返回第一个元素,如果没有则报错Exception in thread "main" java.util.NoSuchElementException
       /* public E element() {
            return getFirst();
        }*/
        System.out.println(list.indexOf("aaaa"));//查找元素
        System.out.println(list.offer("tttt"));//在末尾插入元素--返回是否插入成功
        System.out.println(list.pollFirst());//pollFirst()与poll()方法内容一样
        list.poll();
      /*  public E pollFirst() {
            final LinkedList.Node<E> f = first;
            return (f == null) ? null : unlinkFirst(f);
        }*/

      /*  public E poll() {
            final LinkedList.Node<E> f = first;
            return (f == null) ? null : unlinkFirst(f);
        }*/
//        -----unlinkFirst(f)----
//        private E unlinkFirst(Node<E> f) {
//            // assert f == first && f != null;
//            final E element = f.item;
//            final LinkedList.Node<E> next = f.next;
//            f.item = null;
//            f.next = null; // help GC//删除第一个元素
//            first = next;
//            if (next == null)
//                last = null;
//            else
//                next.prev = null;
//            size--;
//            modCount++;
//            return element;//返回第一个元素
//        }
//      
        //ListIterator<String> stringListIterator = list.listIterator(3);//从指定位置开始返回一个

        System.out.println("------------------------------------------");
        for (int i =0;i<list.size();i++){
            System.out.println(list.get(i));
        }
        System.out.println("------------------------------------------");
        for(String s:list){
            System.out.println(s);
        }
        System.out.println("------------------------------------------");
        Iterator<String> iterator = list.iterator();
        while(iterator.hasNext())
            System.out.println(iterator.next());
        System.out.println("------------------------------------------");
//        for(初始化体;条件;)
//        这种方式节省内存
        for(Iterator<String> it = list.iterator();it.hasNext();)
            System.out.println(it.next());

        
        
    }
}

```



想了想还是取一部分代码给大家看看吧---
关于迭代器的,

```java
  Iterator<String> iterator = list.iterator();
        System.out.println("做一个标记"+iterator.next());

        while(iterator.hasNext())
            System.out.println(iterator.next());
        System.out.println("------------------------------------------");
//        for(初始化体;条件;)
//        这种方式节省内存



        for(Iterator<String> it = list.iterator();it.hasNext();)
            System.out.println(it.next());

```

   上段代码中第二种迭代方式的巧妙之处在于运行完 it对象就被回收了,整个他的生命周期就结束了,节省空间;

强行解释---
for循环是编程语言中一种循环语句，而 循环语句 由 循环体 及循环的判定 条件 两部分组成，其表达式为：for（单次表达式;条件表达式;末尾循环体）

![在这里插入图片描述](https://img-blog.csdnimg.cn/2021071520274782.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81NDA2MTMzMw==,size_16,color_FFFFFF,t_70)
如果it.next()能输出,则会继续循环;

next()注解----

```java
   /**
     * Returns the next element in the iteration.
     *
     * @return the next element in the iteration
     * @throws NoSuchElementException if the iteration has no more elements
     */
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/2021071616101640.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81NDA2MTMzMw==,size_16,color_FFFFFF,t_70)接下来如果要像链表中存入数据,那么就要将我们要存放的数据包装然后放入相应的位置;
第一步--设计一个节点类,用于存放数据
节点类中包含的属性---
上一个节点---Node before;
下一个节点--Node after;
计数器 int count;

> 为了安全,封装一下----设计类的时候都要考虑封装

```java
/**
 * @author : Gavin
 * @date: 2021/7/16 - 07 - 16 - 15:34
 * @Description: LinkedTest
 * @version: 1.0
 */
public class Node {

    private  Node before;//前一个节点
    private  Object obj;
    private  Node after;//后一个节点
    public Node(Node before,Object obj, Node after) {
this.before=before;
this.obj=obj;
this.after=after;
    }
    public Node getBefore() {
        return before;
    }

    public void setBefore(Node before) {
        this.before = before;
    }

    public Object getObj() {
        return obj;
    }

    public void setObj(Object obj) {
        this.obj = obj;
    }

    public Node getAfter() {
        return after;
    }

    public void setAfter(Node after) {
        this.after = after;
    }
}
```

节点类设计完毕,下面做一个测试类;
***框架如下---***

```java
class Mylinked {
public void add(Object obj){}
}

public class Test {
    public static void main(String[] args) {
        Mylinked link = new Mylinked();
        link.add("aaa");
        link.add("bbb");
        link.add("ccc");
       
    }


}
```

以上我们要添加数据,由于没有做类型限制,所以用Object接收;
添加数据之前我们要知道前节点和后节点,
所以在Mylinked类中添加首尾节点,同时还要初始化计数器,
***完善代码---***

```java
class Mylinked {
    Node first;
    Node last;
    int count;
public void add(Object obj){
    
}
}

public class Test {
    public static void main(String[] args) {
        Mylinked link = new Mylinked();
        link.add("aaa");
        link.add("bbb");
        link.add("ccc");
     
       
    }


}
```

接下来完善add方法

如果链表中没有元素,那么first指向为null,根据这一点来逐渐完善代码---

```java
class Mylinked {
    Node first;
    Node last;
    int count;

    public void add(Object obj) {
        Node node = new Node();
        if (first == null) {//如果添加的为第一个元素,那么first==null
            node.setBefore(null);//没有前一个节点.指向空
            node.setObj(obj);
            node.setAfter(null);//没有后一个节点.指向空
            //添加完之后就有了首尾节点,给首位节点赋值
            last = node;//尾节点
            first=node;//下一个元素的首节点--做好记录

        } else {//如果添加的不是第一个元素,
            Node node1 = new Node();
            node1.setBefore(last);//设置该元素的首节点为上一个元素的尾节点
            node1.setObj(obj);//将obj存储
            node1.setAfter(null);//尾节点指向null
            //修改首节点为新添加的元素地址;
            last.setAfter(node1);//设置下一个节点为node1
            last=node1;//赋值

        }
        count++;

    }
    public int size(){//返回链表的数据元素个数
        return count;
    }
    public Object getIndex(int index){

        Node node= first;//找到第一个节点,然后顺藤摸瓜
        
        for(int i=0;i<index;i++){
             node=node.getAfter();
        }
        return node.getObj();
    }
}

public class Test {
    public static void main(String[] args) {
        Mylinked link = new Mylinked();
        link.add("aaa");
        link.add("bbb");
        link.add("ccc");

        System.out.println(link.size());
        System.out.println(link.toString());

        for (int i=0;i<link.size();i++)
        System.out.println(link.getIndex(i));

    }


}
```

接下来做断点测试,验证一下add方法
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210716165515971.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81NDA2MTMzMw==,size_16,color_FFFFFF,t_70)

下面的工作就是去看看源码怎么写的,毕竟他们才是大神;

下面是源码分析---
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210716173859452.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81NDA2MTMzMw==,size_16,color_FFFFFF,t_70#pic_center)



总结---
0,直接将类私有化,免去了包装属性;
1,源码中添加数据直接调用linklast,即先将加进来的数据作为尾节点,然后再去判断是否是第一个,
2,用final去定义数据,保证了添加数据的安全性---所以线程上是安全;
3.所以双向链表比较绕的部分是首尾节点的指向。
4.源码用泛型的好处是取用的时候方便，不用再次转型了！

> 先做一下自我反思--为什么昨天没太理解(实际上理解有偏差),看了源码之后我好像懂了,一看就会,一做就废,果然是学废了;李姐万岁;

链表的头尾原来是链表的头尾-----听起来有些绕
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210717154455617.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81NDA2MTMzMw==,size_16,color_FFFFFF,t_70)



```java
package today;


public class Node<E>{
    Node before;
     E e;
    Node after;

    public  Node(){};//无参构造
    public  Node(E e){
        this();
        this.e=e;
    };
    public Node(Node before ,E e,Node after) {
        this(e);
        this.before=before;
        this.after=after;
    }
    //Setting,getter方法
    public Node getBefore() {
        return before;
    }

    public void setBefore(Node before) {
        this.before = before;
    }

    public E getE() {
        return e;
    }

    public void setE(E e) {
        this.e = e;
    }

    public Node getAfter() {
        return after;
    }

    public void setAfter(Node after) {
        this.after = after;
    }


    public String toString() {
        return "Node{" +
                "before=" + before +
                ", e=" + e +
                ", after=" + after +
                '}';
    }

}
```

***链表的属性中最重要的是Node,然后将要添加的数据封装;***



```java
package today;

/**
 * @author : Gavin
 * @date: 2021/7/17 - 07 - 17 - 8:16
 * @Description: today
 * @version: 1.0
 */

class myLink<E>{
    Node first;
    Node last;
    int count;

    public boolean addFirst(E e){//添加元素使其成为第一个,
        Node<E> node= first;//先找到第一个元素
        Node<E> newNode=new Node<E>(null,e,first);//添加的元素指向原来的第一个节点
        if(node==null){//如果首节点为null,那说明原链表为空
            first=newNode; //新添加的为第一个节点
        }else{//否则说明链表不为空,那么原来首节点的前一个就应该是新添加的
            first.before=newNode;
        }

        first=newNode;//新添加的节点指向添加之前的(即现在的第二个)
        count++;//计数器自增
        return true;

    }
    public Boolean addLast(E e){//在末尾添加元素
        Node<E> node = last;//找到最后一个元素
        Node<E> newNode =new Node<E>(last,e,null);//添加的元素指向原来最后的节点
        last=newNode;//原来尾节点指向新添加的节点
        if (node == null)
           first = newNode;
        else
            node.after = newNode;
        count++;
        return true;
    }



    public Boolean add(E e){
        addLast(e);
        return true;
    }
    public int size(){
        return count;
    }
    public Object getIndex(int index){
        Node node=first;//遍历要从第一个开始,顺藤摸瓜
        for(int i=0;i<index;i++){
            node=node.after;
        }

        return node.e;
    }


}
```

> //方法中最重要的是首尾节点的指向问题,这里处理好了就可以了,添加完元素之后就要修改头尾节点的指向

```java
public class Test {
    public static void main(String[] args) {
        myLink<Integer> node = new myLink<>();
        node.add(111);
        node.add(222);
        node.add(333);
        System.out.println(node.size());
        for(int i=0;i<node.size();i++){
            System.out.println(node.getIndex(i));
        }


    }
}
```

> LinkedList底层是使用Node实现，相比于ArrayList单向链表较耗费空间。
> LinkedList插入，删除节点只需要修改要删除前后的地址将他们连起来即可,效率更高。
> LinkedList查找元素时需要从头使用遍历，效率一般。 LinkedList同时是双向队列的实现。



LinkedList,Iterator与Iterable 的联系与区别;
![](C:\Users\Gavin\Pictures\Camera Roll\1.png)
代码分析----

![](C:\Users\Gavin\Pictures\Camera Roll\2.png)

### HashSet

```java
import java.util.HashSet;
import java.util.Set;
/**
 * @author : Gavin
 * @date: 2021/7/18 - 07 - 18 - 9:13
 * @Description: setTest
 * @version: 1.0
 */
class Person{
    String name;
    int age;
    String gender;

    public Person(String name, int age, String gender) {
        this.name = name;
        this.age = age;
        this.gender = gender;
    }

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", gender='" + gender + '\'' +
                '}';
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Person)) return false;

        Person person = (Person) o;

        if (age != person.age) return false;
        if (!name.equals(person.name)) return false;
        return gender.equals(person.gender);
    }

    @Override
    public int hashCode() {
        int result = name.hashCode();
        result = 31 * result + age;
        result = 31 * result + gender.hashCode();
        return result;
    }
}

public class setHash {
    public static void main(String[] args) {
        Set<Person> hashSet= new HashSet<>();
        Person per= new Person("李一狗",18,"男");
        Person per1= new Person("李二狗",19,"男");
        Person per2= new Person("李三狗",20,"男");
        Person per3= new Person("李四狗",21,"男");
        Person per4= new Person("李一狗",18,"男");
        Person per5= new Person("李六狗",23,"男");
        hashSet.add(per);
        hashSet.add(per1);
        hashSet.add(per2);
        hashSet.add(per3);
        hashSet.add(per4);
        hashSet.add(per5);
       
//        遍历
        for (Person s:hashSet
             ) {
            System.out.println(s);
        }

    }
}

```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210718115529107.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81NDA2MTMzMw==,size_16,color_FFFFFF,t_70)

HasSet无序,且不允许添加重复元素

![1642863278398](C:\Users\Gavin\AppData\Local\Temp\1642863278398.png)
接下来分析一下HashSet的底层是怎么实现的,使用的最新版本jdk16(我有个习惯喜欢追求最新的)

创建对象---

```java
Set<Person> hashSet= new HashSet<>();
```

构造方法---

```java
public HashSet() {   map = new HashMap<>();   }
```

发现HashSet构造中创建了一个HashMap对象

```java
 public HashMap() {//无参数的构造函数，加载因子为默认加载因子0.75
        this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted
    }
```

> 在HashMap中有几个重要参数-- static final float DEFAULT_LOAD_FACTOR = 0.75f;
>
> 学习HashSet就不得不提HashMap
>
> HashMap几个关键的属性-- 
>
> 存储数据的数组   
>
> transient Node<K,V>[] table;
>
> 默认容量 ---- 
>
> static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; 
>
> 最大容量 static final int MAXIMUM_CAPACITY = 1 << 30;
>
> 加载因子是一个比例，当HashMap的数据大小>=容量*加载因子时，HashMap会将容量扩容 
>
> 默认加载因子----
>
> static final float DEFAULT_LOAD_FACTOR = 0.75f;
>
> 当实际数据大小超过threshold--阈值时(如当实际数据大小超过16*0.75=12时会扩容,重新计算存储位置)，HashMap会将容量扩容，
>
> threshold＝容量*加载因子 int threshold; 
>
> 加载因子 ---
>
> final float loadFactor;
>
> 

再来看add()方法---add(per)

```java
public boolean add(E e) {//添加Person对象per
        return map.put(e, PRESENT)==null;
    }

```

这里继续看map,present与put分别代表什么----

```java
//present为Object对象
private static final Object PRESENT = new Object();
```

```java
private transient HashMap<E,Object> map;
```

这里是创建的HashMap对象map,调用put方法

```java
public V put(K key, V value) {
        return putVal(hash(key), key, value, false, true);
    }
```

> return map.put(per, PRESENT)==null; 这里put(per, PRESENT)返回的一个present对应类型的数据--这里是Object类型的,如果返回值为null,则add返回true说明添加成功,否则返回false.添加失败;



再来看---put方法中调用的putVal方法(看起来比较复杂)
传入的参数---
int类型的hash(per)--哈希值,
Person类型的per,
Object类型的 Present
boolean类型的 false
boolean类型的true

> HashMap中的重要属性 ----
> transient Node<K,V>[] table; 
> final int hash;
>         final K key;
>         V value;
>         
> 再看putVal方法之前先看一下resize()方法

```java
final Node<K,V>[] resize() {
        Node<K,V>[] oldTab = table;//将oldTab指向table
        //如果oldTab == null,那么为第一次添加oldCap=0,(如果不是第一次,那么oldCap=oldTab的长度)
        int oldCap = (oldTab == null) ? 0 : oldTab.length;
       //----- int oldCap=0
       // field holds the initial array capacity, or zero signifying
        int oldThr = threshold;//threshold初始值为0--初始化集合
        int newCap, newThr = 0;
        if (oldCap > 0) {//-----若 int oldCap>0,说明不是第一次添加,oldCap=oldTab的长度
            if (oldCap >= MAXIMUM_CAPACITY) {
            // static final int MAXIMUM_CAPACITY = 1 << 30;--一个很大的数了2^31--(计算的时候位移的效率更高)
                threshold = Integer.MAX_VALUE;//也是一个很大的数了
                return oldTab;//返回oldTab
            }
            /**0<oldCap < MAXIMUM_CAPACITY左移一位相当于newCap的平方
            newCap^<2^31并且oldCap>=DEFAULT_INITIAL_CAPACITY(初始值为2^4=16)--*/
            else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&
                     oldCap >= DEFAULT_INITIAL_CAPACITY)
                     //将旧的长度的平方赋值给新长度,
                newThr = oldThr << 1; // double threshold
        }
        else if (oldThr > 0) // initial capacity was placed in threshold
            newCap = oldThr;
        else {               // zero initial threshold signifies using defaults
            newCap = DEFAULT_INITIAL_CAPACITY;//默认16
            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);//0.75*16
        }
        if (newThr == 0) {//如果长度为0,开辟新长度
            float ft = (float)newCap * loadFactor;
            newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?
                      (int)ft : Integer.MAX_VALUE);
        }
        threshold = newThr;
        @SuppressWarnings({"rawtypes","unchecked"})
        Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];
        table = newTab;
        if (oldTab != null) {
            for (int j = 0; j < oldCap; ++j) {
                Node<K,V> e;
                if ((e = oldTab[j]) != null) {
                    oldTab[j] = null;
                    if (e.next == null)
                        newTab[e.hash & (newCap - 1)] = e;
                    else if (e instanceof TreeNode)
                        ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);
                    else { // preserve order
                        Node<K,V> loHead = null, loTail = null;
                        Node<K,V> hiHead = null, hiTail = null;
                        Node<K,V> next;
                        do {
                            next = e.next;
                            if ((e.hash & oldCap) == 0) {
                                if (loTail == null)
                                    loHead = e;
                                else
                                    loTail.next = e;
                                loTail = e;
                            }
                            else {
                                if (hiTail == null)
                                    hiHead = e;
                                else
                                    hiTail.next = e;
                                hiTail = e;
                            }
                        } while ((e = next) != null);
                        if (loTail != null) {
                            loTail.next = null;
                            newTab[j] = loHead;
                        }
                        if (hiTail != null) {
                            hiTail.next = null;
                            newTab[j + oldCap] = hiHead;
                        }
                    }
                }
            }
        }
        return newTab;
    }
```

resize主要是用来扩充大小用的,返回 一个新的newTab

```java
 final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
        Node<K,V>[] tab;//创建新对象tab 
        Node<K,V> p; //创建新对象p
        int n, i;//int 类型的 n,i
        if ((tab = table) == null || (n = tab.length) == 0)//如果tab为空或者tab的长度为0,那么重新为n赋值,
            n = (tab = resize()).length;//
        if ((p = tab[i = (n - 1) & hash]) == null)
            tab[i] = newNode(hash, key, value, null);
        else {//这里决定了不能添加重复元素
            Node<K,V> e; K k;
            if (p.hash == hash &&
                ((k = p.key) == key || (key != null && key.equals(k))))
                e = p;
            else if (p instanceof TreeNode)
                e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
            else {
                for (int binCount = 0; ; ++binCount) {
                    if ((e = p.next) == null) {
                        p.next = newNode(hash, key, value, null);
                        if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                            treeifyBin(tab, hash);
                        break;
                    }
                    if (e.hash == hash &&
                        ((k = e.key) == key || (key != null && key.equals(k))))
                        break;
                    p = e;
                }
            }
            if (e != null) { // existing mapping for key
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;
                afterNodeAccess(e);
                return oldValue;
            }
        }
        ++modCount;
        if (++size > threshold)
            resize();
        afterNodeInsertion(evict);
        return null;
    }
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210718204611143.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81NDA2MTMzMw==,size_16,color_FFFFFF,t_70#pic_center)
做好笔记啊......
为什么是
“e.hash& (newCap-1)”这样做是为了提高HashMap的效率。

首先我们要确定一下，HashMap的默认长度为16,扩容的时候是乘以2^n,因此数组长度一定是偶数，在实际容量达到    容量*0.75即12时开始扩容，

```java
else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&
                     oldCap >= DEFAULT_INITIAL_CAPACITY)
                newThr = oldThr << 1; // double threshold
```

小总结----

所以length-1位奇数，奇数\偶数有什么不同呢?

提高存储位置的均匀性,避免某位置存储过多,而其它位置过少的问题;

hashMap在每次插入数据前，会检查table数组的实际容量，如果实际容量>=初始容量，则把table的初始容量扩为原来的2倍，这时，就需要一个一个复制原来的数据项了，这是比较费时的！所以，初始容量很重要。
由于扩容后要重新计算存储位置,数据量小还可以,如果时千万级的数据,内存的开销---cpu的开销非常大,所以一开始最好是预估一下存储的数量;

在高并发情况下最好不使用HashMap,HashMap是线程不安全的，如果被多个线程共享的操作--后果可想而知------



搞完HashSet,今天来补充一下LinkedHashSet----0720

```java
public class Test {
    public static void main(String args[]) {
        Set<Integer> set=  new LinkedHashSet();
set.add(111);
set.add(333);
set.add(222);
set.add(999);
set.add(777);
        for (Integer integer : set) {
            System.out.println(integer);
        }

        Object[] objects = set.toArray();
        for (Object obj:objects
             ) {
            System.out.println(obj);
        }
        for (int i = 0; i <objects.length ; i++) {
            System.out.println(objects[i]);
        }
    }
}
```

今天突然发现其实集合其实都可以用fori循环进行遍历,只要   用toArray()方法然后用Object数组接收...不过如果要用数据的话得转型,麻烦;

你可能会想,为什么不换成对应的我需要的类?
![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/333a406e5b14a704caa39de3635db5f3.png)

toArray()方法如下,

```java
 public Object[] toArray() {
        Object[] result = new Object[size];
        int i = 0;
        for (Node<E> x = first; x != null; x = x.next)
            result[i++] = x.item;
        return result;
    }
```

其实可以通过覆写的方式来实现我们想要达到的目的,但为题又来了,如果类很多...

所以不如用迭代的方式方便;

```java
import java.util.*;

/**
 * @author : Gavin
 * @date: 2021/7/19 - 07 - 19 - 18:45
 * @Description: setTest
 * @version: 1.0
 */

public class Test {
    public static void main(String args[]) {
        Set<Integer> set = new LinkedHashSet();
        set.add(111);
        set.add(222);
        set.add(113);
        set.add(333);
        set.add(114);
        System.out.print("LinkedHashSet---");
        for (Integer integer : set) {
            System.out.print(integer+"\t");
        }
/*
        Object[] objects = set.toArray();
        for (Object obj : objects
        ) {
            System.out.println(obj);
        }
        for (int i = 0; i < objects.length; i++) {
            System.out.println(objects[i]);
        }*/


        System.out.println();
        System.out.print("HashSet---");
        Set <Integer>set1 = new HashSet();
        set1.add(111);
        set1.add(222);

        set1.add(333);

        set1.add(113);
        set1.add(111);
        set1.add(114);

        for (Integer i:set1
             ) {
            System.out.print(i+"\t");

        }
        System.out.println();
        System.out.print("LinkedList---");
LinkedList<Integer> linkedList= new LinkedList<Integer>();

        linkedList.add(111);
        linkedList.add(222);
        linkedList.add(113);
        linkedList.add(333);
        linkedList.add(114);
        linkedList.add(111);
  Object[] objects3 = linkedList.toArray();
        for (Object obj:objects3
             ) {
            System.out.print(obj+"\t");
        }
        List<Integer> list = new ArrayList();//本身提供了(序号)fori的方式遍历
        list.add(111);
        list.add(222);
        list.add(113);
        list.add(333);
        list.add(114);
        list.add(111);
        System.out.println();
        System.out.print("ArrayList---");
        Object[] objects1 = list.toArray();
        for (int i = 0; i < list.size(); i++) {
            System.out.print(list.get(i)+"\t");
        }

    }
}
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/e09eb3014db3c6d0bef61c99af0e9ffc.png)
**

> 总结--- 
> Arrayist---单向链表--底层实现是数组,连续的空间,查找效率高(索引)
> LinkedList--双向链表,底层实现是链表,不连续的空间,支持高效的插入和删除操作,查找效率低, 都允许插入重复数据,有序;
> HashSet--单向链表+数组实现,底层是map,通过Hashcode和equals来实现非重复和无序的特点,如果要求对象不重复，并且对存取的速度要求高的话，就可以使用HashSet。
> LinkedHashSet--双向链表+数组,因此也是 有序的,如果要保持添加的顺序，可以使用HashSet一个子类，LinkedHashSet。 
> Set还有一个重要的
> 实现类TreeSet，它可以排序,(compareto 和实现compareble两种方式);

### TreeSet

java中集合部分是比较常用的，也会企业要求必须精通的部分；
所以喽，作为小白的我只能看源码度日了；
话不多说，看东西；

```java
public class TodayTest {
    public static void main(String[] args) {
        TreeSet<Integer> set= new TreeSet<Integer>();
        set.add(111);
        set.add(100);
        set.add(101);
        for (Integer integer : set) {
            System.out.println(integer);
        }
    }

}
```

为什么TreeSet添加的数据会进行排序？

回顾---
***先看List接口----***
ArrayList 添加的数据是按照添加顺序排列的，可以添加重复数据；
底层是数组来实现的；
LinkedList添加数据也是按照添加顺序进行排列的，也可以添加重复数据；
底层是数组+链表即哈希表实现的；

ListIterator在迭代时候可以添加数据、移除数据
Iterator在迭代式只可以移除数据

***set接口----***
HasSet--添加的数据是无序的，且不能重复
底层是哈希表，且要实现hashcode和equals方法
LinkedHashSet --添加数据是按照添加顺序添加的，因为底层是数组+链表的形式（双向链表）

调用构造器--
 public TreeMap() {
        comparator = null;
    }
可以发现该构造器中--comparator = null;

> private final Comparator<? super K> comparator;

TreeSet中add方法的实现--

![](C:\Users\Gavin\Pictures\Camera Roll\4.png)



 红黑树----
设置树的颜色的;

```java
private void fixAfterInsertion(Entry<K,V> x) {
        x.color = RED;

        while (x != null && x != root && x.parent.color == RED) {
            if (parentOf(x) == leftOf(parentOf(parentOf(x)))) {
                Entry<K,V> y = rightOf(parentOf(parentOf(x)));
                if (colorOf(y) == RED) {
                    setColor(parentOf(x), BLACK);
                    setColor(y, BLACK);
                    setColor(parentOf(parentOf(x)), RED);
                    x = parentOf(parentOf(x));
                } else {
                    if (x == rightOf(parentOf(x))) {
                        x = parentOf(x);
                        rotateLeft(x);
                    }
                    setColor(parentOf(x), BLACK);
                    setColor(parentOf(parentOf(x)), RED);
                    rotateRight(parentOf(parentOf(x)));
                }
            } else {
                Entry<K,V> y = leftOf(parentOf(parentOf(x)));
                if (colorOf(y) == RED) {
                    setColor(parentOf(x), BLACK);
                    setColor(y, BLACK);
                    setColor(parentOf(parentOf(x)), RED);
                    x = parentOf(parentOf(x));
                } else {
                    if (x == leftOf(parentOf(x))) {
                        x = parentOf(x);
                        rotateRight(x);
                    }
                    setColor(parentOf(x), BLACK);
                    setColor(parentOf(parentOf(x)), RED);
                    rotateLeft(parentOf(parentOf(x)));
                }
            }
        }
        root.color = BLACK;
    }
```



刚开始学西二叉树,不知道分析的对不对,请大佬们指正...万分感激

> 今天（0722）再回来看一下put方法，添加的元素相同，则返回V----value的值，因为TreeSet只添加了一个元素（虽然是add方法，但是底层是用put方法实现的），是用TreeMap来保存--即V--value始终为空
>
> 而	TreeMap是以键值对存储的，所以添加的元素相同时则返回V----value的值不是null

### HashMap与HashTable

岁岁年年人不同，年年岁岁花相似；

> 数据结构---大数据方向必须要掌握的，之前一直想的是从事大数据方向，现在感觉那么遥远。。。。打工人。。。加油

```java
package com.Date.Test;

import java.util.*;

/**
 * @Auther: GavinLim
 * @Date: 2021/7/21 - 07 - 21 - 15:50
 * @Description: com.Date.Test
 * @version: 1.0
 */
public class TodayTest {
    public static void main(String[] args) {

        Map<String,Integer>map = new HashMap<>();
        //添加数据----返回值为V类型
       /* public V put(K key, V value) {
            return putVal(hash(key), key, value, false, true);


        }*/

        map.put("张三",18);
        map.put("李四",18);
        map.put("王五",18);
        map.put("张三",19);
        map.put("赵六",18);
        map.put("郑八",18);
        Integer pu = map.put("郑八", 18);

        map.put("王十", 20);
        Integer pu1 = map.put("测试",10);
        System.out.println("添加重复元素返回---该元素的V--value值"+pu);
        System.out.println("添加非重复元素返回--"+pu1);
        System.out.println("集合大小"+map.size());
        System.out.println(map);
        //删除数据--返回值为Integer类型的信息
      /*  public V remove(Object key) {
            TreeMap.Entry<K,V> p = getEntry(key);
            if (p == null)
                return null;

            V oldValue = p.value;
            deleteEntry(p);
            return oldValue;
        }*/
        Integer  zs= map.remove("张三");//会移除哪一个张三的信息呢？
        System.out.println("移除的是"+zs);
        boolean te = map.remove("测试", 10);

        //        map.clear();//移除所有数据
        //查找数据
        Integer g = map.get("郑八");
        System.out.println(g);
//将键值作为一个集合
        Set<Map.Entry<String, Integer>> entries = map.entrySet();
        for (Map.Entry<String, Integer> entry : entries) {

            System.out.println(entry.getKey()+"----------"+entry.getValue());

        }
        System.out.println("--------------------");
        //得到value的集合
        Collection<Integer> values = map.values();
        for (Integer value : values) {

            System.out.println(value);
        }
    }

}


```

```java
Picked up JAVA_TOOL_OPTIONS: -Dfile.encoding=UTF-8
添加重复元素返回---该元素的V--value值18
添加非重复元素返回--null
集合大小7
{李四=18, 张三=19, 王五=18, 测试=10, 王十=20, 赵六=18, 郑八=18}
移除的是19
18
李四----------18
王五----------18
王十----------20
赵六----------18
郑八----------18
--------------------
18
18
20
18
18
```

------



 ArrayList       底层是Object[]数组，构造方法有三个,效率高，但是线程不安全
 ![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/d267496a28c3866379d22a9eb52be576.png)

只看---  ArrayList ()  ArrayList( int 初始容量)
  每次插入都要检查容量是否足够,
无参构造---在第一次插入数据后才开始将数组扩容为10

> return elementData = new Object[Math.max(DEFAULT_CAPACITY,
> minCapacity)];
> 有参构造是直接返回我们指定的大小；
> 扩容机制----第一次添加数据是扩容为10，第二次扩容的时候为原来的1.5倍即15（newCapacity = oldCapacity + (oldCapacity >> 1);）第三次是22，第四次是33以此类推。。。。。

Vector底层也是Object[]数组，构造方法四种，可以分别指定标准容量和指定增量，
![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/f46ab3842365911f5740b71845cf036e.png)扩容是每次扩容的时候是原来的二倍----无参构造
有参构造如Vector(10,3)则每次扩容增量为3，即 10,13,16.。。。
有参构造且没指定增量其实也是调用了参数为两个的构造，只不过增长量为0，那么每次扩容也是原来的2倍；

> int newLength = Math.max(minGrowth, prefGrowth) + oldLength;

LikedList---扩容----对不起，没有----因为是双向链表结构，可以随时添加，没有容量限制
![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/9f0dde0b618b81b374a4c4bd34c817c4.png)

再来看Set接口中的
突然想到Set的底层其实是map来实现的，所以先看Map，那么对应的Set的扩容机制也就自然带出来了；
首先看Map接口中的HashMap；
![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/1221931bc8e02c461d1bfd6e5f6b36e8.png)HashMap构造有四个，只看前三个

HashMap()---空构造器---先加载的是导入因子，扩容也是在添加第一个元素之后再开始扩容，第一次扩容为16

> public HashMap() {
>        this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted
>    }
>
> else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&
>                     oldCap >= DEFAULT_INITIAL_CAPACITY)

当添加的数据达到初始容量*加载因子的时候开始扩容，

> newCap = DEFAULT_INITIAL_CAPACITY;
>             newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);

扩容机制---每次扩容是原来的二倍；

> ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&
>                     oldCap >= DEFAULT_INITIAL_CAPACITY)
>                newThr = oldThr << 1;

HashMap(int 初始容量)---加载因子也是默认0.75，容量达到初始容量*加载因子的时候开始扩容，底层也是 resize ()扩容方法，扩容后大小是原来的二倍

 HashMap(int 初始容量，加载因子)容量达到初始容量*加载因子的时候开始扩容，扩容后大小是原来的二倍

------

> HashSet的扩容跟HashMap 一样；LinkedHashMap（HashMap的子类）也是；

------

TreeMap的扩容机制---对不起，也没有

![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/662da8337d982fe80a343f079c47472f.png)Stack

  继承于Vector，所以他的扩容机制等同于Vector的默认情况，也就是2倍速度扩容

### Iterator与ListIterator迭代的区别

迭代的时候可以修改数据吗?
答,Iterator迭代的时候可以移除数据,但是不能添加;而ListIterator迭代时可以添加数据,移除数据,倒序遍历;

```java
public class Bianli {
    public static void main(String[] args) {
        ArrayList<String> list= new ArrayList<>();
        list.add("aaa");
        list.add("sss");
        list.add("ddd");
        list.add("fff");
        list.add("ggg");
        Iterator<String> iterator = list.iterator();

        while(iterator.hasNext()){
            if(iterator.next().equals("ddd")){
                list.add("eee");//不可以添加,
                iterator.remove();//但是可以移除

            }

        }
        for (String s:list
             ) {
            System.out.println(s);
        }
        }
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210717214839929.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81NDA2MTMzMw==,size_16,color_FFFFFF,t_70)这个迭代器只有remove方法,无add方法,要想添加数据得靠list对象,但是这时候如果通过list添加数据,就相当于有两个人同时操作一个数据,会产生
Exception in thread "main" java.util.ConcurrentModificationException

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210717215049385.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81NDA2MTMzMw==,size_16,color_FFFFFF,t_70)而ListIterator迭代器提供了add方法,可以通过迭代器进行添加数据,而不用通过集合对象添加;

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210717215421136.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81NDA2MTMzMw==,size_16,color_FFFFFF,t_70)

```java
package today;

import java.util.*;

/**
 * @author : Gavin
 * @date: 2021/7/17 - 07 - 17 - 21:23
 * @Description: today
 * @version: 1.0
 */
public class Bianli {
    public static void main(String[] args) {
        ArrayList<String> list= new ArrayList<>();
        list.add("aaa");
        list.add("sss");
        list.add("ddd");
        list.add("fff");
        list.add("ggg");
        Iterator<String> iterator = list.iterator();

        while(iterator.hasNext()){
            if(iterator.next().equals("ddd")){
                //list.add("eee");//不可以添加,
                iterator.remove();//但是可以移除

            }

        }
        for (String s:list
             ) {
            System.out.println(s);
        }
        List <String>list1 = new ArrayList<>();
        list1.add("111");
        list1.add("222");
        list1.add("444");
        list1.add("666");
        list1.add("888");
        ListIterator<String> iterator1 = list1.listIterator();
        while(iterator1.hasNext()){
            if("444".equals(iterator1.next())){
                iterator1.remove();
                iterator1.add("333");

            }
        }
        for (String str : list1) {
            System.out.println(str);
        }
    }
}

```

![](C:\Users\Gavin\Pictures\Camera Roll\3.png)

我们还可以倒叙迭代,通过listiterator的hasPrevious()方法--因为当我们正序迭代完之后,光标指针已经到了尾部了;

```java
System.out.println(iterator1.hasNext());
       System.out.println(iterator1.hasPrevious());
        while(iterator1.hasPrevious()){
            System.out.println(iterator1.previous());
        }
    }
```

### 

***2021.07.22日更新***

### Collection接口和Collections的区别

```java
package HuiXin;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class Test {
    public static void main(String[] args) {
        ArrayList<Integer>list= new ArrayList<>();
        list.add(111);
        list.add(99);
        list.add(222);
        list.add(88);
        boolean b = Collections.addAll(list,1,12,15);
        Collections.addAll(list,new Integer[]{12,13,1,45,78,5,45,4556});

        Collections.sort(list);
        System.out.println(list);
        System.out.println(Collections.binarySearch(list,4556));
        List<Integer>list1= new ArrayList<>();
        list1.add(12);
        list1.add(67);
        Collections.copy(list,list1);
        System.out.println(list1);
        System.out.println(list);
    }
}

```

注意的点是----
Collection接口和Collections区别
接口---
public interface Collection<E> extends Iterable<E> {
Collection接口的实现类---ArrayList，LinkedList，HashSet，TreeSet  
类--
public class Collections {
    // Suppresses default constructor, ensuring non-instantiability.
    private Collections() {/私有构造方法
    }
    既然是私有构造方法，说明不能被实例化，然后会发现该类中的方法都为静态方法，可以直接通过类名调用，这样做的好处是什么呢？
该类为public，但是类中所以的属性和方法都为静态的（除了构造方法）

![在这里插入图片描述](https://img-blog.csdnimg.cn/5e5f35fe48134795babb04289ef25699.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81NDA2MTMzMw==,size_16,color_FFFFFF,t_70)
注意BinarySearch的方法查询之前要先进行排序



# java中容器的发展史

在jdk 1.*版本的时候,主要的容器有  Vector(实现List接口)和HashTable(实现Map接口),随着jdk版本的衍变,同时为了处理高并发环境下的事务,jdk后来又添加了一些适合于高并发情况下的容器;现在我们循着历史的脚步一起探究一下java中的容器,以及了解为什么有些容器的实现已淡出我们的视野;

## collection接口
继承实现关系---->>>
public interface Collection<E> extends Iterable<E>
![在这里插入图片描述](https://img-blog.csdnimg.cn/d6dfd23fe34049ab83617db15ea2d288.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAR2F2aW5fTGlt,size_20,color_FFFFFF,t_70,g_se,x_16)接口中的方法----->>>
![在这里插入图片描述](https://img-blog.csdnimg.cn/b4322dc4fec04171b744f9522966624b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAR2F2aW5fTGlt,size_20,color_FFFFFF,t_70,g_se,x_16)


该接口下有很多实现类,

按照存储的特点来分:
    **存储一个  List,Set和Queue,
   存储键值对的 map**
按照继承实现关系来分:
**List
Set
Queue
Map**

不着急,一个一个来:先看容器的根接口----->>>Collection接口

**该接口的描述---->**
**集合**层次结构中的**根接口**。  一个集合代表一组对象，称为它的元素。  一些集合允许重复元素，而另一些则不允许。  有些是有序的，有些是无序的。  JDK 不提供此接口的任何直接实现：它提供了更具体的子接口（如 Set 和 List）的实现。  此接口通常用于传递集合并在需要最大通用性的地方操作它们。

Collection接口中的默认方法------>>
![在这里插入图片描述](https://img-blog.csdnimg.cn/3ac13d2950fb4b25919108fb5ae3d97a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAR2F2aW5fTGlt,size_20,color_FFFFFF,t_70,g_se,x_16)

> 关于默认方法,子类可以选择去实现也可以选择不实现;

## List接口
list接口的实现类----->>>
从最早的Vector, Stack到ArrayList,LinkedList.CopyOnWriteList
![在这里插入图片描述](https://img-blog.csdnimg.cn/062416d3212144849d897e66604bd54e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAR2F2aW5fTGlt,size_20,color_FFFFFF,t_70,g_se,x_16)![在这里插入图片描述](https://img-blog.csdnimg.cn/3b72bb6b42b94c9091dde4f869f6803d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAR2F2aW5fTGlt,size_20,color_FFFFFF,t_70,g_se,x_16)List中的静态方法----->>>

```java
import java.util.List;
public class ListDemo {
    public static void main(String[] args) {
        List<String> he = List.of("你好");
        he.add("hello");
        he.forEach(s -> {
            System.out.println(s);
        });
    }
}

```
可以看到of方法返回的是一个不可修改的List集合;
```java
Exception in thread "main" java.lang.UnsupportedOperationException
```


## Vector及其子类Stack

### Vector

```java

import java.util.Collection;
import java.util.Iterator;
import java.util.Vector;
import java.util.stream.Stream;

class Person{
    String name;

    public Person(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                '}';
    }
}
public class Vector_1Demo {
    public static void main(String[] args) {
      /*  如果没有指定容量则默认为10,增长因子为0*/
        Collection<Person>c=new Vector<>(100,12);
        c.add(new Person("张三"));
        c.add(new Person("李四"));
        System.out.println(c.size());
      /* Vector 支持迭代器,不支持下标式的访问;*/
        for (Person per:
           c  ) {
            System.out.println(per);
        }
        Iterator<Person> iterator = c.iterator();
        while(iterator.hasNext()){
            System.out.println(iterator.next());
        }
        //流式操做 stream,感兴趣可以查一下API
        Stream<Person> personStream1 = c.parallelStream();
        personStream1.forEach(person -> System.out.println(person));
       
        Stream<Person> personStream = c.parallelStream();
        personStream.forEach(person -> System.out.println(person));
    }
}
```
来看API---->>
**Vector的继承实现关系**
public class Vector<E> extends AbstractList<E>
implements List<E>, RandomAccess, Cloneable, Serializable

描述:Vector类实现了一个**可增长的数组 对象**。 像数组一样，它包含的组件可以是 使用**整数索引访问**。 然而，一个大小 Vector可以根据需要增长或缩小以适应 添加和删​​除项目之后

类中的方法不必多说,重点关注一下两点----
构造方法---->>

类的构造----

![在这里插入图片描述](https://img-blog.csdnimg.cn/c4f544ced9d5482685b57b68a2287cdb.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAR2F2aW5fTGlt,size_20,color_FFFFFF,t_70,g_se,x_16)截取部分方法----->
![在这里插入图片描述](https://img-blog.csdnimg.cn/8e4893cc05264cb49be5c2fdcde07487.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAR2F2aW5fTGlt,size_20,color_FFFFFF,t_70,g_se,x_16)Vector的底层构造----->>

Vector维护了三个变量------
Object[] elementData--------数组
int elementCount------>>元素数量
int capacityIncrement---->>>容量扩充
![在这里插入图片描述](https://img-blog.csdnimg.cn/a79f12ca676845d48f237c702d4d6b4e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAR2F2aW5fTGlt,size_20,color_FFFFFF,t_70,g_se,x_16)
Vector的扩容机制----->>>
1,如果有通过构造方法指定初始容量和容量扩充,那么当容量不够时,Vector会扩充为  旧的长度+扩容长度
2,如果没有指定扩容量,则扩容时容量变为扩容时的两倍
![在这里插入图片描述](https://img-blog.csdnimg.cn/b62a2940ad854be182709567498223f0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAR2F2aW5fTGlt,size_20,color_FFFFFF,t_70,g_se,x_16)
Vector类中的大部分方法都是加了锁的,因此在高并发情况下添加或者移除元素的效率不如ArrayList,但是线程安全
**以卖票为例子**
```java
import java.util.Vector;
public class TicketSeller02 {
    static Vector<String>vector= new Vector<>();
    static {
        for (int i = 1; i <11; i++) {
            vector.add("第--"+i+"张票");
        }
    }
    public static void main(String[] args) {
        for (int i = 0; i < 10; i++) {
            new Thread(()->{while (vector.size()>0){
            //原子方法----size()
//如果在这之间有一些其他操做也是需要加锁的,因为原子操做与原子操做之间是不确保线程安全的;
//原子方法---remove();
                System.out.println(vector.remove(0));}
            }).start();
        }
    }
}
```

### Stack
public class Stack<E> extends Vector<E>

描述---->>
这 Stack类代表后进先出 (LIFO) 对象堆栈。 

首次创建堆栈时，它不包含任何项目。

Deque接口及其实现提供了一套更完整、更一致的 LIFO 堆栈操作，应优先于此类使用。例如：
 Deque<Integer> stack = new ArrayDeque<Integer>();

```java
import java.util.Stack;
public class StackDemo {
    public static void main(String[] args) {
        Stack<Integer>stack= new Stack<>();
        stack.add(10);
        stack.add(88);
        stack.add(99);
        stack.add(111);
        stack.add(88);
        Integer peek = stack.peek();//查看栈顶元素,而不将其移除栈;
        System.out.println("A-栈顶元素"+peek);//111
        System.out.println("B-栈顶元素"+stack.push(4444));//将4444压入栈顶
        Integer pop = stack.pop();
        System.out.println("移除栈顶元素"+pop);
        System.out.println("检查此时的栈顶元素--"+stack.peek());
        System.out.println("88所在栈的位置--"+stack.search(88));//返回对象在此堆栈上的从 1 开始的位置。 

    }
}

```


小结---->>>>

![在这里插入图片描述](https://img-blog.csdnimg.cn/287447aa04da4d4985dd450828722960.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAR2F2aW5fTGlt,size_20,color_FFFFFF,t_70,g_se,x_16)由于历史原因,你会发现有些容器多次实现了同一个接口比如Vector继承AbstractList,而AbstractList实现了List,但Vector也实现了List接口;




## ArrayList和LinkedList

### ArrayList 

> public class ArrayList<E> extends AbstractList<E> implements List<E>, RandomAccess, Cloneable, Serializable

描述:可调整大小的数组实现 List界面。也是列表操作，并允许所有元素，包括 null. 除了实施 List界面， 此类提供操作数组大小的方法 在内部用于存储列表。 （这个类大致相当于 Vector，除了它是不同步的。） 


ArrayList的插入效率是比较高的,add()方法的时间复杂度O(N)

如果**多个线程同时访问**一个 ArrayList实例， 并且至少有一个线程在**结构上修改**了列表，它 **必须 在外部同步**。 （结构修改是 **添加或删除**一个或多个元素的任何操作，或显式 **调整后备数组的大小**； 仅仅设置元素的值不是 结构修改。）这通常是通过 同步一些自然封装列表的对象。 如果不存在这样的对象，则应使用 **Collections.synchronizedList方法。**

> List list = Collections.synchronizedList(new ArrayList(...));

![在这里插入图片描述](https://img-blog.csdnimg.cn/e7a56385f5e14279b7072174389b1308.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAR2F2aW5fTGlt,size_20,color_FFFFFF,t_70,g_se,x_16)

```java
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class ArrayListDemo {
    public static void main(String[] args) {
        ArrayList<Integer>list= new ArrayList<>();
//        使得这个list变为线程安全的集合
        List<Integer> synList = Collections.synchronizedList(list);
//        非同步的添加
        list.add(0);
//        同步的添加
      synList.add(1);
        list.forEach(i->{
            System.out.println(i);
        });

        for (int i = 0; i < list.size(); i++) {
            System.out.println(list.get(i));
        }
        //返回元素的位置----如果有多个,则返回第一个
        System.out.println(synList.indexOf(0));
        //返回这个list的浅拷贝---即只是元素的拷贝,地址是不一样的
        Object clone = list.clone();
        System.out.println(clone);
        ArrayList list1=list;//这个是深拷贝,元素和地址都拷贝
        
    }
}
```
**以售票为例子**
```java
public class TicketSeller {
    static List<String> list= new ArrayList<>();
    static{
        for (int i = 1; i < 11; i++) {
            list.add("第--"+i+"张票");
        }
    }
    public static void main(String[] args) {
        List<String> list1 = Collections.synchronizedList(list);
        for (int i = 0; i < 10; i++) {
            new Thread(()->{
                while(list1.size()>0){
                    System.out.println(list1.remove(0));
                }
            }).start();
        }

    }
}
```



ArrayList的底层原理---->>> 数组

在ArrayList的底层维护了两个变量----

>  **transient Object[] elementData;**  
>   **private int size;**

![在这里插入图片描述](https://img-blog.csdnimg.cn/16c3047cbd76401296795815f18dbb71.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAR2F2aW5fTGlt,size_20,color_FFFFFF,t_70,g_se,x_16)

ArrayList的扩容原理---->>
说到扩容原理先看构造方法----->>
不指定初始容量即 new ArrayList()这是默认容量为10
![在这里插入图片描述](https://img-blog.csdnimg.cn/6abeea3ff1324f97879383925fa91318.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAR2F2aW5fTGlt,size_20,color_FFFFFF,t_70,g_se,x_16)扩容原理---->>

当我们用无参构造创建集合时;
虽然说默认容量是10,但它是在添加第一个元素时才生效的;

![](C:\Users\Gavin\Pictures\Camera Roll\52.png)

小结--->>>

1,ArrayList中扩容机制----当实际大小减去指定大小大于0时才开始扩容,扩容为原来的1.5倍,节省空间

2,ArrayList中的方法为非同步,但是也可以通过Collections工具类使其变为同步的List
![在这里插入图片描述](https://img-blog.csdnimg.cn/ae460bf12a144dcfa53e7f087595affa.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAR2F2aW5fTGlt,size_20,color_FFFFFF,t_70,g_se,x_16)

#### Vector与ArrayList区别
底层的实现原理是一样的，但是Vector扩容时时扩容为原来的2倍；
另一个Vector的方法时加了sycn同步的，所以是支持原子的，但是锁的粒度是比较大的因为都加载了方法上；
###  LinkedList 
继承实现关系:
public class LinkedList<E>
extends AbstractSequentialList<E>
implements List<E>, **Deque**<E>, Cloneable, Serializable

描述:----双向链表的实现了 List和 Deque接口。允许所有 元素（包括 null). 

 如果多个**线程同时访问一个链表**，并且至少 其中一个线程在结构上修改了列表，它 必须 是 外部同步。 （**结构修改是任何操作 添加或删除一个或多个元素； 仅设置值 元素不是结构修改。**）这通常是 通过同步一些自然而然的对象来完成 封装列表。 如果不存在这样的对象，则应使用 **Collections.synchronizedList方法。** 这最好在创建时完成，以防止意外 对列表的非同步访问：

> **List list = Collections.synchronizedList(new LinkedList(...));**

**构造方法**
![在这里插入图片描述](https://img-blog.csdnimg.cn/2822d3421528484b8287f313d93327f9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAR2F2aW5fTGlt,size_20,color_FFFFFF,t_70,g_se,x_16)

```java
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;
public class LinkedListDemo {
    public static void main(String[] args) {
        LinkedList<Integer>linkedList= new LinkedList<>();
        List<Integer> lks = Collections.synchronizedList(linkedList);//同步链表
        linkedList.add(0);
        lks.add(100);
        linkedList.add(0,12);
        System.out.println(lks);
        System.out.println(linkedList.peek());//返回第一个元素
        System.out.println(linkedList.peekFirst());
        System.out.println(linkedList.peekFirst());//返回第一个元素
        System.out.println(linkedList.peekLast());//返回最后一个元素
        System.out.println(linkedList.element());//返回第一个元素
        System.out.println(linkedList.offer(88));//链表尾部插入一个元素
        System.out.println(linkedList.offerFirst(99));//链表头部插入一个元素
        System.out.println(linkedList.offerLast(100));//链表尾部插入一个元素
        System.out.println(linkedList);
        System.out.println(linkedList.poll());//检索并删除第一个元素,返回这个元素
        System.out.println(linkedList.pollFirst());//检索并删除第一个元素,返回这个元素
        System.out.println(linkedList.pollLast());//检索并删除最后一个元素,返回这个元素
        System.out.println(linkedList);
        linkedList.removeFirst();//移除第一个
        linkedList.removeLast();//移除第二个
    }
}
```
链表在查询数据时效率低,因为要遍历整个集合,但是在插入数据时效率较高!

LinkedList的底层实现----->
底层维护了一个节点以及大小
![在这里插入图片描述](https://img-blog.csdnimg.cn/e14f3fd45eb04d7696301ca1c0fe757c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAR2F2aW5fTGlt,size_20,color_FFFFFF,t_70,g_se,x_16)

### LinkedeList和ArrayList的区别

1、底层存储的数据结构不同,ArrayList是Object(动态数组)的数据结构，LinkedList是Node(链表)的数据结构。
2,ArrayList由于时数组,可以通过下标快速查询数据而linkedlist是通过指针进行移动来查询数据的,
3,LinkedList在增加和删除数据时效率较高,
在API中没有发现LinkedList关于容量的一些信息------即Linkedlist不用考虑初始容量的问题,即用多少就是多少,不需要预留容量;


### CopyOnWriteArrayList
继承实现关系:

> public class CopyOnWriteArrayList<E> extends Object implements List<E>, RandomAccess, Cloneable, Serializable

描述信息:
线程安全的变体 **ArrayList其中所有突变** 操作（ add, set，等等）由 制作底层数组的新副本。

这通常成本太高，但可能 更 有效 当遍历操作数量远远超过替代方案时 突变，当你不能或不想时很有用 同步遍历，但需要排除之间的干扰 并发线程。

简单的说就是一个关于读写的线程安全的一个ArrayList
构造方法--->>

![在这里插入图片描述](https://img-blog.csdnimg.cn/da3c1560008f457c9fa9fad8b3239114.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAR2F2aW5fTGlt,size_20,color_FFFFFF,t_70,g_se,x_16)

```java
import java.util.ArrayList;
import java.util.concurrent.CopyOnWriteArrayList;
public class CopyOnWriteArraylistDemo {
    public static void main(String[] args) {
        //创建一个空列表
        CopyOnWriteArrayList<Integer> copy = new CopyOnWriteArrayList<>();
        //线程安全的写操做
        //写互斥
        copy.add(0);
        copy.add(1);
//     读共享
        Integer integer = copy.get(0);
        System.out.println("_________________");
        ArrayList<Integer> list = new ArrayList<>(10);
        list.add(0);
        list.add(1);
        list.add(2);
        list.add(3);
        CopyOnWriteArrayList CWASList=new CopyOnWriteArrayList(list);
        CWASList.add(100);

        System.out.println(CWASList);
        Object []objects= new Object[100];
        CopyOnWriteArrayList ca=new CopyOnWriteArrayList(objects);
        ca.add(999);
        System.out.println(ca);
    }
}
```
这个类的一个好处是,对于高并发环境下,同时读读是不需要加锁的,读写,写读,写写操做需要加锁,这类似于读写锁的实现;

先看一下写操做的add()方法---->>
![在这里插入图片描述](https://img-blog.csdnimg.cn/be686dd575a24ef1b78177b8c33bd9c3.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAR2F2aW5fTGlt,size_20,color_FFFFFF,t_70,g_se,x_16)
在这个类中那个关于添加数据的都加了不同粒度的锁,关于读取数据的都没有加锁;

这个相比于ArrayList,能做到线程安全,但是如果数据量太多,那么对于服务器的开销会很大,因为是通过在拷贝上修改来实现线程安全的,通过这个拷贝来替换掉原来的;

**以售票为例子**
```java
public class TicketSeller02 {
    static CopyOnWriteArrayList<String> coa=new CopyOnWriteArrayList<>();
    static {
        for (int i = 1; i <11 ; i++) {
            coa.add("第--"+i+"张票");
        }
    }
    public static void main(String[] args) {     
        for (int i = 0; i < 10; i++) {
            new Thread(()->{while (coa.size()>0){
                System.out.println(coa.remove(0));}
            }).start();
        }

    }
}
```




小结:-----

1,本身线程安全(读与写)的容器-----vector ,stack   读写都加了锁;
2,读写不安全的  ArrayList和Linkedlist,不过可以通过Collections工具类的	synchronizedList​ 来返回一个安全的容器读写都加了锁)
3,读安全(未加锁),写安全的(加锁)CopyOnWriteArrayList,原理时写的时候拷贝一份,在末尾把添加进的元素塞进去;


## Set接口
继承实现关系--->

public interface Set<E> extends Collection<E>

描述:
**不包含重复元素的集合。**更正式地说，集合不包含一对元素 e1 和 e2，使得 e1.equals(e2)，并且最多包含一个空元素。
该接口的实现类中一些集合实现对它们可能包含的元素有限制。例如，有些**实现禁止空元素**，有些实现对其元素的类型有限制。

> Set.of 和 Set.copyOf 静态工厂方法提供了一种创建不可修改集的便捷方法。  这些方法创建的 Set 实例具有以下特点：

  1. 它们是不可修改的。  不能添加或删除元素。  调用 Set 上的任何 mutator 方法将始终导致抛出 
    UnsupportedOperationException。
  2. 如果包含的元素本身是可变的，这可能会导致 Set 的行为不一致或它的内容似乎发生了变化。
  3. 它们不允许空元素。  尝试使用空元素创建它们会导致 NullPointerException。
  4. 如果所有元素都可序列化，则它们是可序列化的。
  5. 他们在创建时拒绝重复的元素。  传递给静态工厂方法的重复元素会导致 IllegalArgumentException

**接口中的方法----->**
![在这里插入图片描述](https://img-blog.csdnimg.cn/3fca4031df7c427bb3955561eb4b58d1.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAR2F2aW5fTGlt,size_20,color_FFFFFF,t_70,g_se,x_16)![在这里插入图片描述](https://img-blog.csdnimg.cn/7963643e7b8749bdb0ebb93f4392fafd.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAR2F2aW5fTGlt,size_20,color_FFFFFF,t_70,g_se,x_16)

### HashSet 及其子类LinkedHashSet

#### HashSet

继承实现关系------>>
public class HashSet<E> extends AbstractSet<E>
implements Set<E>, Cloneable, Serializable

描述:
这个类实现了 Set接口，由**哈希表**支持 （实际上是一个 HashMap实例）。 它**不保证 集合的迭代顺序；** 特别是，它不保证 随着时间的推移，订单将保持不变。 这个类允许 **null 元素。** 

此实现**不是同步的**。如果**多个线程同时访问**哈希集，并且**至少有一个线程修改了集**，则**必须外部同步**。这通常是通过在自然封装集的某个对象上同步来实现的。如果没有此类对象，则应使用集合"包装"。同步集法。最好在创建时间完成此工作，以防止意外的不同步访问集：

**Set s = Collections.synchronizedSet(new HashSet(...));**


构造方法:
![在这里插入图片描述](https://img-blog.csdnimg.cn/fb3d4ac7b29c4a00af1b7f73006b8790.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAR2F2aW5fTGlt,size_20,color_FFFFFF,t_70,g_se,x_16)HashSet的底层维护了一个HashMap,
![在这里插入图片描述](https://img-blog.csdnimg.cn/eb11e33f930443f6a6173d2b36a270d1.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAR2F2aW5fTGlt,size_20,color_FFFFFF,t_70,g_se,x_16)

```java
import java.util.HashSet;
import java.util.Set;
public class HashSetDemo {
    public static void main(String[] args) {
        //无参构造---默认16,加载因子0.75
        Set<Integer>set= new HashSet<>();
        set.add(1);
        set.add(6);
        set.add(1);
        set.add(null);
        set.add(2);
        System.out.println(set);//[null, 1, 2, 6]--说明后面重复的元素被自动过滤掉,按照升序排列
        //只指定初始容量,加载因子仍默认为0.75
        Set<Integer>set1= new HashSet<>(8);
        //指定初始容量,同时指定加载因子
        Set<Integer>set2= new HashSet<>(8,1);
    }
}

```

HashSet容量初始化分析--->>>>
![](C:\Users\Gavin\Pictures\Camera Roll\53.png)

hashSet怎么做到没有重复元素?

![](C:\Users\Gavin\Pictures\Camera Roll\54.png)

关于HashSet添加的顺序是无序的,即不是按照我们添加使得顺序显示的;

例如以下代码------>>>

```java
public class HashSetDemo {
    public static void main(String[] args) {
        //无参构造---默认16,加载因子0.75
        Set<Integer>set= new HashSet<>();
        set.add(9);
        set.add(6);
        set.add(5);
        set.add(7);
        set.add(8);
        set.add(7);
        System.out.println(set);
        //只指定初始容量,加载因子仍默认为0.75
        Set<Integer>set1= new HashSet<>(8);
        //指定初始容量,同时指定加载因子
        Set<Integer>set2= new HashSet<>(8,1);
    }
}

```
![在这里插入图片描述](https://img-blog.csdnimg.cn/e2be0f0b76dc4c5f996a2723805654dd.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAR2F2aW5fTGlt,size_20,color_FFFFFF,t_70,g_se,x_16)

#### 小结HashSet:

1,底层是通过hashmap实现的,只不过用了键值对中的key;
2,扩容机制是 (无参构造)  容量=阈值时开始扩容,每次扩容为原来的2倍;
3,hashset中添加的元素要求实现hashCode()方法和equals()方法
##### 为什么默认加载因子为0.75呢?

> 因为当加载因子太小时hash碰撞的概率会增加,这使得数据分布不均匀;当加载因子太大时,会产生空间上的浪费,所以去一个折中值0.75;

### LinkedHashSet
继承实现关系---->
public class LinkedHashSet<E>
extends HashSet<E> implements Set<E>, Cloneable, Serializable

描述:

**哈希表和链表的实现** Set界面， 具有可预测的迭代顺序。 这个实现不同于 HashSet因为**它维护一个双向链表**贯穿 它的所有条目。 这个链表定义了迭代顺序， 这是元素插入集合的顺序 （ 插入顺序 ）。 

请注意，插入顺序 不 影响 如果一个元素被 重新插入 到集合中。 （一个元素 e 重新插入到一个集合中 s如果 s.add(e)被调用时 s.contains(e)会回来 true紧接在之前 调用。） 

请注意，此**实现不是同步的**。 如果**多个线程同时访问一个链接的散列集**，并且**至少 其中一个线程修改了集合**，它 必须 是**同步的 外部**。 这通常是通过同步一些 自然封装集合的对象。 如果不存在这样的对象，则应使用 Collections.synchronizedSet方法。 这最好在创建时完成，以防止意外 对集合的非同步访问：

> Set s = Collections.synchronizedSet(new LinkedHashSet(...));

底层实现原理----->>>
哈希表和双向链表

构造函数----->跟HashSet形式是一样的;
![在这里插入图片描述](https://img-blog.csdnimg.cn/b0d09a08d6104ecabafdc82f8dc6914c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAR2F2aW5fTGlt,size_20,color_FFFFFF,t_70,g_se,x_16)![在这里插入图片描述](https://img-blog.csdnimg.cn/c2fa0710878043b584e39caf362b867d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAR2F2aW5fTGlt,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)除了双向链表,其他方面跟HashSet基本是一样的;


小结:
1,LinkedHashSet中元素排序是有序的,因为可以通过双向链表的形式找到每一个元素;
2,底层依旧是hashMap,在HashSetde 基础上多维护了一个链表;用的是hash表和双向链表来实现的
3,LinkedHashSet中添加的元素要求实现hashCode()方法和equals()方法

### EnumSet---抽象类
继承实现关系:

> public abstract class EnumSet<E extends Enum<E>> extends
> AbstractSet<E> implements Cloneable, Serializable

描述:
一个专门的 Set用于枚举类型的实现。 所有的 枚举集中的元素必须来自单个枚举类型，即 在创建集合时显式或隐式指定。 枚举集 在内部表示为位向量。 这种表示是 非常紧凑和高效。 这个时空表现 类应该足够好以允许将其用作高质量的类型安全 替代传统 int-基于“位标志”。 甚至散装 操作（例如 containsAll和 retainAll） 应该 如果他们的参数也是枚举集，则运行速度非常快。 

像大多数集合实现一样， **EnumSet不是 同步**。 如果多个线程**同时访问一个枚举集**，并且在 至少有一个线程修改了集合，它应该是**同步的 外部**。 这通常是通过同步一些 **自然封装枚举集的对象**。 如果不存在这样的对象， 该集合应该使用 Collections.synchronizedSet(java.util.Set<T>)方法。 这最好在创建时完成，以防止意外 非同步访问：

Set<MyEnum> s = Collections.synchronizedSet(EnumSet.noneOf(MyEnum.class));

  由于该类为抽象类,类中的方法都为静态方法,所以在创建枚举集合的时候可以通过类名调用静态方法;
![在这里插入图片描述](https://img-blog.csdnimg.cn/8b99722433b04c4b9062a61f7faebba1.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAR2F2aW5fTGlt,size_20,color_FFFFFF,t_70,g_se,x_16)

简单地说,EnumSet是专门为枚举类集合设计的,因此在添加和取出枚举值时操做要比HashSet要快!!

```java
import java.util.EnumSet;
public class EnumSetDemo {
    public static void main(String[] args) {
        //创建一个枚举集合,包含没居中所有元素
        EnumSet<FRUIT> fruits = EnumSet.allOf(FRUIT.class);
        fruits.add(FRUIT.FRUIT1);
        System.out.println(fruits.size());
//拷贝一个fruits
        EnumSet<FRUIT> fruits1 = EnumSet.copyOf(fruits);
//创建一个指定为枚举类型为FRUIT的空的集合,
        EnumSet<FRUIT> fruits2 = EnumSet.noneOf(FRUIT.class);
        System.out.println(fruits2.size());
        EnumSet<FRUIT> clone = fruits.clone();
    }

}
```

我很是好奇,于是做了个不成熟的实验------>>
有这样一个枚举 FRUIT,里面有十个枚举元素
分别往 HashSet 和EnumSet里面添加;
本实验为重复100000次(扩大时间以便于观察)

```java
import gavin.CollectionDemo.Other.FRUIT;
import java.util.EnumSet;
import java.util.HashSet;
import java.util.Set;
public class EnumSetDemo {
    //准备好容器
    static EnumSet<FRUIT> fruits2 = EnumSet.noneOf(FRUIT.class);
    static HashSet<FRUIT> hashSet = new HashSet<>();
    //将枚举值一个个去除放到数组中
    static FRUIT fruits[] = FRUIT.values();
    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(() -> {
          long  start = System.currentTimeMillis();
            for (int i = 0; i < 100000; i++) {
                AddE(hashSet);
                RemoveE(hashSet);
            }
            long end = System.currentTimeMillis();
            System.out.println(end - start);
        });
        Thread thread1 = new Thread(() -> {
          long  start = System.currentTimeMillis();
            for (int i = 0; i < 100000; i++) {
                AddE(fruits2);
                RemoveE(fruits2);
            }
            long end = System.currentTimeMillis();
            System.out.println(end - start);
        });
        thread.start();
       //thread1.start();
       thread.join();
       // thread1.join();
//thread  ----44
//thread1-----14

    }

    //    拆开挨个添加   
    static void AddE(Set set) {
        for (FRUIT fruit :
                fruits) {
            set.add(fruit);
        }
    }//

    // 拆开挨个移除
    static void RemoveE(Set set) {
        for (FRUIT fruit :
                fruits) {
            set.remove(fruit);
        }
    }
}

```

### SortedSet 接口
**继承实现关系----->>**

public interface SortedSet <E> extends Set<E>

描述:

种 Set这进一步提供了 的 **排序 其元素** 。 元素使用它们的 排列 自然 顺序 ，或由 **Comparator**通常在排序时提供 设置创建时间。 **集合的迭代器将遍历集合 元素升序。 提供了几个额外的操作 以利用排序**。 （这个界面是设置 类似物 SortedMap.)

**插入到有序集合中的所有元素都必须实现 Comparable接口**（或**被指定的比较器接受**）。 此外，所有 这些元素必须 相互比较 ： **e1.compareTo(e2)** （或者 **comparator.compare(e1, e2))** 不得抛出 ClassCastException对于任何元素 e1和 e2在 排序集。 试图违反此限制将导致 引发错误的方法或构造函数调用 ClassCastException.

请注意，排序集维护的排序（无论是否为 提供了显式比较器）必须 与 equals 一致， 如果 排序集是为了正确实现 Set集合。

所有通用排序集实施类应提供四个"标准"构造器：
1） **空（无参数）构造器，该构造符创建根据其元素的自然顺序排序的空排序集。**

2） **具有单个类型参数的构造器，该构造器创建根据指定的比较器排序的空排序集。**

3） **具有单个类型参数的构造器，该构造器创建具有与其参数相同的元素的新排序集，根据元素的自然顺序进行排序。**

4） **具有单个类型参数的构造器，该构造器创建具有与输入排序集相同的元素和相同排序的新排序集。无法执行此建议，因为界面无法包含构造器。ComparatorCollectionSortedSet**

![在这里插入图片描述](https://img-blog.csdnimg.cn/2bfdbd93840a463887a50835f4d20e87.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAR2F2aW5fTGlt,size_20,color_FFFFFF,t_70,g_se,x_16)

```java
import java.util.Objects;
import java.util.SortedSet;
import java.util.TreeSet;
class Student implements Comparable {
    int S_id;
    String S_name;
    int S_age;
    public Student() {
    }
    @Override
    public String toString() {
        return "Student{" +
                "S_id=" + S_id +
                ", S_name='" + S_name + '\'' +
                ", S_age=" + S_age +
                '}';
    }

    public Student(int s_id, String s_name, int s_age) {
        S_id = s_id;
        S_name = s_name;
        S_age = s_age;
    }
    @Override
    public int compareTo(Object o) {
        //这里要检查o的类型的,省略了
       Student s= (Student)o;
        return this.S_id-s.S_id;
    }
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Student student = (Student) o;
        return S_id == student.S_id &&
                S_age == student.S_age &&
                S_name.equals(student.S_name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(S_id, S_name, S_age);
    }
}

public class SortedSetDemo {
    public static void main(String[] args) {
        SortedSet<Student>sortedSet=new TreeSet<>();
        sortedSet.add(new Student(1001,"扎根三",20));
        sortedSet.add(new Student(1008,"李四",20));
        sortedSet.add(new Student(1004,"王五",20));
        sortedSet.add(new Student(1007,"赵六",20));
        sortedSet.add(new Student(1009,"乾七",20));
        sortedSet.add(new Student(1012,"六八",20));
        for (Student s :
                sortedSet) {
            System.out.println(s);
        }

    }
}
```


#### SortedSet 接口实现类----TreeSet
继承实现关系----->
public class TreeSet<E> extends AbstractSet<E>
implements NavigableSet<E>, Cloneable, Serializable

怎么没看到 实现了SortedSet?,别急看这个
**public interface NavigableSet<E> extends SortedSet<E>** 

TreeSet描述:
一种 **NavigableSet**实现基于 **TreeMap**. 元素使用它们的 排列 自然 订购 ，或由 **Comparator在集合创建时提供** 时间，取决于使用的构造函数。

此实现为基本的 log(n) 时间成本提供了保证 操作（ add, remove和 contains). 

请注意，此实现**不是同步的**。 如果**多个线程同时访问一个树集，并且至少有一个 的线程修改集合，它 必须 是同步的 外部。 这通常是通过同步一些 自然封装集合的对象。 如果不存在这样的对象，则应使用 Collections.synchronizedSortedSet方法。** 这最好在创建时完成，以防止意外 对集合的非同步访问：

> **SortedSet s = Collections.synchronizedSortedSet(new TreeSet(...));**

构造函数总结
TreeSet() 	
构造一个新的空树集，根据 其元素的自然排序。

TreeSet​(Collection<? extends E> c) 	
构造一个包含指定元素的新树集 收集，根据排序 自然排序 的其 元素。

TreeSet​(Comparator<? super E> comparator) 	
构造一个新的空树集，按照指定的排序 比较器。


TreeSet​(SortedSet<E> s) 	
构造一个包含相同元素的新树集 使用与指定排序集相同的顺序。 

```java
import java.util.Comparator;
import java.util.TreeSet;
class Animal implements Comparator {
    int A_id;
    String name;
    public Animal(int a_id, String name) {
        A_id = a_id;
        this.name = name;
    }
    @Override
    public String toString() {
        return "Animal{" +
                "A_id=" + A_id +
                ", name='" + name + '\'' +
                '}';
    }
    @Override
    public int compare(Object o1, Object o2) {
        int result = ((Animal) o1).A_id - ((Animal) o2).A_id;
        return result;
    }
}
public class TreeSetDemo {
    public static void main(String[] args) {
//        一个空的构造
        TreeSet<Integer> treeSet = new TreeSet<>();
        //构建包含指定集合中元素的新树集，根据其元素的自然顺序进行排序。
        TreeSet<Integer> treeSet1 = new TreeSet<>(treeSet);
        Animal [] animal= new Animal[10];
        //实现Comparator接口

        TreeSet<Animal> treeSet2 = new TreeSet<>((o1, o2) -> o1.A_id-o2.A_id);
        TreeSet<Animal> treeSet3 = new TreeSet<>(Comparator.comparingInt(o -> o.A_id));
        for (int i = 0; i < animal.length; i++) {
            animal[i]=new Animal(i,"狗");
            treeSet3.add(animal[i]);
        }
        for (Animal a :
                treeSet3) {
            System.out.println(a);
        }
    }
}

```
注意:往set集合中放自定义数据时要注意实现compareable或者comparator接口,同事要实现hash和equals方法,在实际应用中有可能还需要实现序列化;

#####  CopyOnWriteArraySet

public class CopyOnWriteArraySet<E>
extends AbstractSet<E> implements Serializable


用于所有**操作的内部副本执行列表**的集。因此，它具有相同的基本属性：
它最适合设置大小通常保持小，仅读操作大大超过突变操作的应用程序，并且您需要防止在横穿过程中线程之间的干扰。
它是线程安全。
add set remove 操作（等）开销很大，因为它们通常需要复制整个底层阵列。
这个也是读读共享和CopyOnWriteArrayList基本一样;
还是看以下add 方法
![在这里插入图片描述](https://img-blog.csdnimg.cn/b3518fa5d239413ba74c8aa8ef481b5b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAR2F2aW5fTGlt,size_20,color_FFFFFF,t_70,g_se,x_16)


重点在下面这个类----->>

####  ConcurrentSkipListSet
继承实现关系
public class ConcurrentSkipListSet<E>
extends AbstractSet<E>
implements NavigableSet<E>, Cloneable, Serializable

描述:
**可扩展的并发 NavigableSet实施基于 一种 ConcurrentSkipListMap.** 集合的元素被保留 根据它们的 自然顺序排序 ， 或由 Comparator在设置创建时间提供，取决于 在哪个构造函数上使用。

此实现提供**预期的平均 log(n) 时间 成本** contains, add， 和 remove操作及其变体** 插入、移除和访问 操作由多个线程安全地并发执行。**

与大多数集合不同， **size方法 不是 恒定时间操作**。 由于 这些**集合的异步性质**，确定当前数量 of elements 需要遍历元素，因此可能会报告 如果在遍历期间修改此集合，则结果不准确。 


![在这里插入图片描述](https://img-blog.csdnimg.cn/d986bef37a9340cdb0d1cbb337e08cd3.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAR2F2aW5fTGlt,size_20,color_FFFFFF,t_70,g_se,x_16)底层是通过ConcurrentNavigableMap来实现的

> private final ConcurrentNavigableMap<E,Object> m;

```java
class PersonP implements Comparable {
    int P_ID;
    String name;
    int age;
    String gender;

    public PersonP() {
    }
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        PersonP personP = (PersonP) o;
        return P_ID == personP.P_ID &&
                age == personP.age &&
                Objects.equals(name, personP.name) &&
                Objects.equals(gender, personP.gender);
    }

    @Override
    public int hashCode() {
        return Objects.hash(P_ID, name, age, gender);
    }

    public PersonP(int p_ID, String name, int age, String gender) {
        P_ID = p_ID;
        this.name = name;
        this.age = age;
        this.gender = gender;
    }

    @Override
    public int compareTo(Object o) {
        PersonP p = (PersonP) o;
        return this.P_ID - p.P_ID;
    }

    @Override
    public String toString() {
        return "PersonP{" +
                "P_ID=" + P_ID +
                ", name='" + name + '\'' +
                ", age=" + age +
                ", gender='" + gender + '\'' +
                '}';
    }
}

public class CurrentSkipListSetDemo {
    public static void main(String[] args) {
        //无参构造
        ConcurrentSkipListSet<PersonP> concurrentSkipListSet = new ConcurrentSkipListSet();
        concurrentSkipListSet.add(new PersonP(1001, "李四", 20, "男"));
        concurrentSkipListSet.add(new PersonP(1006, "王四", 22, "男"));
        concurrentSkipListSet.add(new PersonP(1004, "赵四", 21, "男"));
//取出数据
        for (PersonP p :
                concurrentSkipListSet) {
            System.out.println(p);
        }

        //        有参构造
        Set<Integer> set = new HashSet<>();
        ConcurrentSkipListSet cSL = new ConcurrentSkipListSet(set);
        Comparator comparator = cSL.comparator();
        System.out.println("comparator = " + comparator);
        ConcurrentSkipListSet cSL2 = new ConcurrentSkipListSet((o1, o2) -> {
            if(o1 instanceof PersonP&&o2 instanceof PersonP){
                PersonP  per= (PersonP)o1;
                PersonP  per2= (PersonP)o1;
                return per.P_ID-per2.P_ID;
            }
          return  0;
        });
    }
}
```

想要搞清楚为什么 ConcurrentSkipListSet是线程安全的,那就需要看一下源码------>>>

我们平常说的线程安全大部分都是指读写,写写之间会出现的一些问题,读读之间没有什么影响;



简单的看了一些源码------>>
![](C:\Users\Gavin\Pictures\Camera Roll\55.png)

下面没有再继续分析,感兴趣你可以分析一下;

![](C:\Users\Gavin\Pictures\Camera Roll\56.png)



![](C:\Users\Gavin\Pictures\Camera Roll\57.png)

jdk1.5开始,Collection接口又增加了一个子接口 Queue




# Queue 接口
继承实现关系---->>
public interface Queue<E> extends Collection<E>

描述:

专为在**处理前保存元素而设计的集合**。除了基本的收集操作外，队列**还提供额外的插入、提取和检查操作**。这些方法都以两种形式存在：一种是操作失败时抛出异常，另一种是返回特殊值（或者，取决于操作）。插入操作的后一种形式是专门为容量限制实现而设计的：在大多数实现中，插入操作不能失败。

![在这里插入图片描述](https://img-blog.csdnimg.cn/849f9f75d52c41bfaae83f62096c0244.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAR2F2aW5fTGlt,size_20,color_FFFFFF,t_70,g_se,x_16)

## Queue的子接口---->>>Deque
继承实现关系------>>>
public interface Deque<E> extends Queue<E>

描述:
支持**两端元素插入和删除的线性集合**。双端队列"的简称，通常发音为"甲板"。大多数实施对可能包含的元素数量没有固定限制，但此接口支持容量限制的 deque 以及没有固定大小限制的除数。Deque提供插入、删除和检查元素的方法。这些方法都以两种形式存在：一种是操作失败时抛出异常，另一种是返回特殊值（或者，取决于操作）。插入操作的后一种形式是专门为容量限制实现而设计的：在大多数实现中，插入操作不能失败。


方法:

![在这里插入图片描述](https://img-blog.csdnimg.cn/2f2eed942c0946bc85e3f0596b974c8d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAR2F2aW5fTGlt,size_20,color_FFFFFF,t_70,g_se,x_16)
接口中定义了一些方法,需要子类去实现,先看看ArrayDeque吧.

### ArrayDeque
public class ArrayDeque<E>
extends AbstractCollection<E>
implements Deque<E>, Cloneable, Serializable

描述:
**可调整阵列**实现。阵列偏点没有容量限制;它们根据需要生长以支持使用。它们**不安全**：在没有外部同步的情况下，它们**不支持多个线程的并发访问**。**禁止使用空元素**。

构造方法:

![在这里插入图片描述](https://img-blog.csdnimg.cn/e579e32e27da4284839231cc8163a4fd.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAR2F2aW5fTGlt,size_20,color_FFFFFF,t_70,g_se,x_16)
ArrayDeque的底层原理:
![在这里插入图片描述](https://img-blog.csdnimg.cn/6501f6f2f556468eab7251dbefb18f28.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAR2F2aW5fTGlt,size_20,color_FFFFFF,t_70,g_se,x_16)
维护了数组,头部和尾部;
ArrayDeque的扩容原理-------->>

![在这里插入图片描述](https://img-blog.csdnimg.cn/35e174a904ce4d87995b30e47252603a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAR2F2aW5fTGlt,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)

```java
public class QueueDemo {
    public static void main(String[] args) {
        Deque<Integer>deque= new ArrayDeque<>();
        deque.add(0);
        System.out.println(deque.size());
        deque.addFirst(99);//可以向前插,也可以向后插
        deque.addLast(88);//add也是用到了addLast()
        System.out.println(deque.element());//返回第一个元素
        System.out.println(deque.getFirst());//头
        System.out.println(deque.getLast());//尾
        Iterator<Integer> integerIterator = deque.descendingIterator();//得到一个倒叙的迭代器
        for (Iterator<Integer> it = integerIterator; it.hasNext(); ) {
            Integer integer = it.next();
            System.out.print(integer+"");
        }
        System.out.println(deque);
        }
        }
```
ArrayDeque的优势:

> **此类在用作堆栈时可能比堆栈更快即比stack要快(因为Stack中的方法有些是加了锁的)，在用作队列时比链接列表快即比 LinkedList要快,不用维护节点,底层是数组的形式;**
> 大多数操作在摊销的恒定时间内运行。例外情况包括删除、删除第一次发生、删除上次事件、包含、重复器、删除 （）和批量操作，所有这些操作都是在线性时间运行的。
> ArrayDeque实现了 先进先出或者先进后出,而Stack是先进后出;

```java
public class QueueDemo {
    public static void main(String[] args) {
        Deque<Integer>deque= new ArrayDeque<>();
        //进栈
        deque.add(0);//tail
        deque.addLast(1);
        deque.addLast(2);
        deque.addFirst(3);
        deque.addFirst(4);
        deque.addFirst(5);
//      出栈
        deque.getFirst();
        deque.getLast();
        deque.poll();
        deque.pollFirst();
        deque.pollLast();
        //Stack
        Stack<Integer>stack= new Stack<>();
        stack.add(1);
        stack.peek();

    }
}
```
### ConcurrentLinkedDeque
继承实现关系------>>>
public class **ConcurrentLinkedDeque**<E>
extends AbstractCollection<E>
implements Deque<E>, Serializable


无界**并发 双端队列** 基于链接节点 。 **并发插入、移除和访问操作安全执行 跨多个线程。** 一种 ConcurrentLinkedDeque是一个合适的选择，当 许多线程将共享对公共集合的访问。 像大多数其他并发集合实现一样，这个类 **不允许使用 null元素。**

![在这里插入图片描述](https://img-blog.csdnimg.cn/4a82e6fd10d54e91ba656ab2fc8bea54.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAR2F2aW5fTGlt,size_20,color_FFFFFF,t_70,g_se,x_16)
底层实现原理--->>节点

![在这里插入图片描述](https://img-blog.csdnimg.cn/923597a0984c4039a7e6f1ef67f35653.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAR2F2aW5fTGlt,size_20,color_FFFFFF,t_70,g_se,x_16)

```java
import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedDeque;
public class ConcurrentLinkedDequeDemo {
    public static void main(String[] args) {
        Queue<Integer> q= new ConcurrentLinkedDeque<>();
        q.add(1);//底层是用的offer，所以推荐用offer方法
        System.out.println(q.poll());//返回第一个并在队列中删除
        System.out.println(q.size());
        q.offer(2);
        System.out.println(q.peek());//返回第一个但是不删除
        System.out.println(q.element());//底层是peek方法,所以推荐用peek
        System.out.println(q.remove());//底层是poll方法
        q.offer(null);//抛异常
        System.out.println(q);
    }
}
```

## Deque子接口----BlockingDeque接口
继承实现关系---->>
public interface BlockingDeque<E>
extends BlockingQueue<E>, Deque<E>

另一种支持阻塞操作的Deque容器，在检索元素时等待Deque容器变为非空容器，在存储元素时等待Deque容器中有可用空间。  

BlockingDeque方法有四种形式，具有不同的处理操作的方法，这些操作不能立即得到满足，但可能在将来的某个时候得到满足: 第一个抛出异常，第二个返回一个特殊值(null或false，取决于操作)，第三个阻塞当前线程，直到操作成功，第四个阻塞只有给定的最大时间限制，然后放弃。  

![在这里插入图片描述](https://img-blog.csdnimg.cn/a78dc3525f6b41d4bb55aa808f472d96.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAR2F2aW5fTGlt,size_20,color_FFFFFF,t_70,g_se,x_16)

## LinkedBlockingDeque
继承实现关系----->>
public class LinkedBlockingDeque<E>
extends AbstractQueue<E>
implements BlockingDeque<E>, Serializable
底层----->维护了节点,同时因为加了锁,可以保证线程安全;
![在这里插入图片描述](https://img-blog.csdnimg.cn/ac482cb42ee24fef8b8f117dab29d871.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAR2F2aW5fTGlt,size_20,color_FFFFFF,t_70,g_se,x_16)
```java

import java.util.concurrent.BlockingDeque;
import java.util.concurrent.LinkedBlockingDeque;

public class BlockingQueueDemo {
    public static void main(String[] args) {
//        默认创建一个Integer.MAX_VALUE大小的阻塞队列
        BlockingDeque<Integer> bd=new LinkedBlockingDeque<>()  ;
        System.out.println(bd.size());
        bd.add(1);
        bd.offer(2);
        bd.addFirst(3);
        bd.addLast(4);
        bd.offerFirst(5);
        bd.offerLast(10);
        bd.removeFirst();
        bd.removeLast();
        System.out.println(bd.size());
    }
}

```

![在这里插入图片描述](https://img-blog.csdnimg.cn/19d6097dedd74a1c8262af099c353469.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAR2F2aW5fTGlt,size_20,color_FFFFFF,t_70,g_se,x_16)


```java
import java.util.concurrent.LinkedBlockingDeque;
public class LinkedBlockingDequeDemo {   static  LinkedBlockingDeque<String> blockingDeque=new LinkedBlockingDeque<>();
static{
    for (int i = 1; i < 1000; i++) {
        blockingDeque.offerFirst("第--"+i+"张票");
    }
}

    public static void main(String[] args) {
        for (int i = 0; i < 100; i++) {
            new Thread(()->{
                while (true){
                    String s = blockingDeque.pollFirst();
                    if(s==null) break;
                    System.out.println(s);
                }
            }).start();
        }

    }

}

```



### LinkedBlockingDeque与ArrayDeque对比
相同点:
1, 都是双向队列,都继承了Deque
不同点:

1,LinkedBlokingDeque线程安全,而ArrayDeque不安全
**ArrayDeque默认初始容量为16+1,而LinkedBlockingDeque默认为Integer最大值;**

LinkedBlockingDeque是一个线程安全的双向队列
在Deque的体系结构，实现一个Deque可以使用数组（ArrayDeque），同时也可以使用链表（LinkedList），还可以同实现一个支持阻塞的线程安全版本队列LinkedBlockingDeque。


## Queue 接口
继承实现关系----->
public interface Queue<E> extends Collection<E>

描述:
设计用于在处理之前保存元素的集合。 除了基本款 Collection操作，队列提供 额外的插入、提取和检查操作。 这些方法中的每一种都以两种形式存在：**一种是抛出异常 如果操作失败，另一个返回一个特殊值（或者 null或者 false，取决于操作）。** 这 后一种形式的插入操作是专门为 与容量限制一起使用 Queue实施； 多数情况 实现，插入操作不会失败。 

队列通常**（但不一定）对元素中的元素进行排序 FIFO（先进先出）方式。** 例外情况包括 优先级队列，根据提供的元素对元素进行排序 比较器，或元素的自然顺序，和 LIFO 队列（或 堆栈）对元素 LIFO（后进先出）进行排序。 
![在这里插入图片描述](https://img-blog.csdnimg.cn/deab465781974232866508d56584f474.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAR2F2aW5fTGlt,size_20,color_FFFFFF,t_70,g_se,x_16)
###  ConcurrentLinkedQueue
无界线程安全 队列 基于链接节点 。 该队列对元素 FIFO（先进先出）进行排序。 的 头部 队列 是已经在队列中的那个元素 排队时间最长。 的 尾部 队列 是已经在队列中的那个元素 排队时间最短。 新元素 插入到队列尾部，队列检索 操作获取队列头部的元素。 一种 ConcurrentLinkedQueue是一个合适的选择，当 许多线程将共享对公共集合的访问。 像大多数其他并发集合实现一样，这个类 不允许使用 null元素。

此实现采用了高效 的非阻塞 基于在中描述的算法 简单、快速、实用的非阻塞和阻塞并发队列 算法 ;

![在这里插入图片描述](https://img-blog.csdnimg.cn/0fff7e9214384ae882cd52968152c2a5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAR2F2aW5fTGlt,size_20,color_FFFFFF,t_70,g_se,x_16)

```java
import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;

public class ConcurrentLinkedQueueDemo {
    public static void main(String[] args) {

        Queue<Integer>lq= new ConcurrentLinkedQueue<>();
        Thread []threads=new Thread[10];
        for (int i = 0; i < 10; i++) {
          threads[i]=  new Thread(()->{
                for (int j = 0; j < 1000; j++) {
                    lq.offer(j);
                }
            });
        }
        for (int i = 0; i < threads.length; i++) {
            threads[i].start();
            try {
                threads[i].join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println(lq.size());
    }
}
```

添加方法/移除基于CAS操做,所以效率是比较高的;

![在这里插入图片描述](https://img-blog.csdnimg.cn/7fcc1c2c75c64d66becb968b56bd6a6f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAR2F2aW5fTGlt,size_20,color_FFFFFF,t_70,g_se,x_16)


## Queue 的子接口----BlockingQueue
public interface BlockingQueue<E> extends Queue<E>

描述:
支持在检索元素时等待队列变得非空的操作的队列，以及在存储元素时等待队列中可用的空间。

BlockingQueue实现设计主要用**于生产者-消费者队列**，但还支持集合界面。因此，例如，可以从队列中删除任意元素。但是，**此类操作通常执行效率不高**，并且仅用于偶尔使用，例如当已排队的消息被取消时。remove(x)

BlockingQueue实现是**线程安全的**。所有排队方法都使**用内部锁或其他形式的并发控制实现其原子效果**。但是，批量收集操作，并且不一定以原子方式执行，除非在实施中另有说明。因此，例如，在只添加一些元素后，可能会失败（抛出一个例外）

```java
class Producer implements Runnable {
   private final BlockingQueue queue;
   Producer(BlockingQueue q) { queue = q; }
   public void run() {
     try {
       while (true) { queue.put(produce()); }
     } catch (InterruptedException ex) { ... handle ...}
   }
   Object produce() { ... }
 }

 class Consumer implements Runnable {
   private final BlockingQueue queue;
   Consumer(BlockingQueue q) { queue = q; }
   public void run() {
     try {
       while (true) { consume(queue.take()); }
     } catch (InterruptedException ex) { ... handle ...}
   }
   void consume(Object x) { ... }
 }

 class Setup {
   void main() {
     BlockingQueue q = new SomeQueueImplementation();
     Producer p = new Producer(q);
     Consumer c1 = new Consumer(q);
     Consumer c2 = new Consumer(q);
     new Thread(p).start();
     new Thread(c1).start();
     new Thread(c2).start();
   }
 }
```
![在这里插入图片描述](https://img-blog.csdnimg.cn/b9ba6c9b421240c29885428f434cac80.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAR2F2aW5fTGlt,size_20,color_FFFFFF,t_70,g_se,x_16)
**Queue的实现类---->**

### ArrayBlockingQueue

public class **ArrayBlockingQueue**<E> extends AbstractQueue<E> implements BlockingQueue<E>, Serializable

描述:
有界 阻塞队列 。 该队列对元素 FIFO（先进先出）进行排序。 这 **头部 队列的 是已经在队列中的那个元素 排队时间最长。** 的 **尾部 队列 是 排队时间最短的元素**。 **新元素 插入到队列尾部，队列检索 操作获取队列头部的元素。**

这是一个经典的“有界缓冲区”，其中一个 固定大小的数组包含生产者插入的元素和 由消费者提取。 一旦创建，容量就不能 改变了。 **尝试去 put一个元素进入一个完整的队列 会导致操作阻塞； 尝试去 take一个 来自空队列的元素同样会阻塞。**

此类支持用于订购的可选公平策略 等待生产者和消费者线程。 默认情况下，此排序 不保证。 然而，一个用公平集构造的队列 到 true按 FIFO 顺序授予线程访问权限。 公平 通常会降低吞吐量但会减少可变性并避免 饥饿。

此类及其迭代器实现了所有 可选的 的方法 Collection和 Iterator接口。 

构造方法--->>
![在这里插入图片描述](https://img-blog.csdnimg.cn/3c9ce3d82b8f4537a372c98667cea17f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAR2F2aW5fTGlt,size_20,color_FFFFFF,t_70,g_se,x_16)

```java

public class ArrayBlockingQueueDemo {
    public static void main(String[] args) {
        //指定容量
        BlockingQueue<Integer> blockingQueue = new ArrayBlockingQueue<>(3);
        blockingQueue.add(1);
        blockingQueue.add(2);
        blockingQueue.add(3);
        System.out.println(blockingQueue);

        blockingQueue.poll();//不保证先进先出原则
        blockingQueue.add(4);
        System.out.println(blockingQueue);
        blockingQueue.remove();//尝试从空队列中移除元素将同样阻塞
        System.out.println(blockingQueue);
        //设置为true,以保证先进先出
        BlockingQueue<Integer> blockingQueue2 = new ArrayBlockingQueue<>(3, true);
        ArrayDeque<Integer> arrayDeque = new ArrayDeque<>();
        BlockingQueue<Integer> blockingQueue3 = new ArrayBlockingQueue<>(3, true, arrayDeque);
        blockingQueue3.add(1);
        blockingQueue3.add(1);
        blockingQueue3.add(1);

        System.out.println(blockingQueue3);
    }

```
![在这里插入图片描述](https://img-blog.csdnimg.cn/1433413b533b452a8ca2530f309fdf43.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAR2F2aW5fTGlt,size_20,color_FFFFFF,t_70,g_se,x_16)

![](C:\Users\Gavin\Pictures\Camera Roll\62.png)

进一步分析底层实现原理------->>>

![](C:\Users\Gavin\Pictures\Camera Roll\58.png)



入队和出队的源码分析---->>

![](C:\Users\Gavin\Pictures\Camera Roll\60.png)



![在这里插入图片描述](https://img-blog.csdnimg.cn/32e44163339542c9a8140d34960bc485.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAR2F2aW5fTGlt,size_20,color_FFFFFF,t_70,g_se,x_16)

```java
import java.util.ArrayDeque;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;

public class ArrayBlockingQueueDemo {
    public static void main(String[] args) {
        //指定容量
        BlockingQueue<String> blockingQueue = new ArrayBlockingQueue<>(10);
        //添加10个元素
        for (int i = 0; i < 10; i++) {
            blockingQueue.add("a"+i);
        }
//满了之后在添加,add方法添加时报异常
       // boolean qq = blockingQueue.add("qq");//java.lang.IllegalStateException: Queue full
//        满了之后在添加,offer不报异常,返回添加成功或者失败
        boolean qq = blockingQueue.offer("qq");
//        往外取
        for (int i = 0; i < 10; i++) {
            blockingQueue.poll();
        }
//       取空之后
        System.out.println("取空之后再取为---"+blockingQueue.poll());//null
        System.out.println(blockingQueue.remove());//remove 则报异常
    }

}

```


如果对于容量没有限制,可以用LinkedBlockingQueue;

### LinkedBlockingQueue;




### PriorityBlockingQueue

继承实现关系---->>>
public class **PriorityBlockingQueue**<E>
extends AbstractQueue<E>
implements BlockingQueue<E>, Serializable

描述:
一个**无界 阻塞队列** ，使用 与**类相同的排序规则** PriorityQueue和用品 阻止检索操作。 虽然这个队列在逻辑上是 无限制，尝试添加可能会因资源耗尽而失败 （导致 OutOfMemoryError）。 **不允许 null元素**。 依赖 优先级队列 自然排序的 也**不允许插入 不可比较的对象**（这样做会导致 ClassCastException).

此类及其迭代器实现了所有 可选的 的方法 Collection和 Iterator接口。 方法中提供的迭代器 iterator()和 方法中提供的Spliterator spliterator(),**不 保证遍历 PriorityBlockingQueue 中的元素 任何特定的顺序。** 如果您**需要有序遍历，请考虑使用 Arrays.sort(pq.toArray()).** 还有方法 drainTo能够 用于 删除 按优先级顺序 部分或全部元素和 将它们放在另一个集合中。 

![在这里插入图片描述](https://img-blog.csdnimg.cn/4492df035f354d03b5d60d9692d19684.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAR2F2aW5fTGlt,size_20,color_FFFFFF,t_70,g_se,x_16)

## 卖票的实现几种方式


1,通过	Collections工具类中的synchronizedList 方法转换为线程安全的list
```java
public class TicketSeller {
    static List<String> list= new ArrayList<>();
    static{
        for (int i = 1; i < 11; i++) {
            list.add("第--"+i+"张票");
        }
    }
    public static void main(String[] args) {
        List<String> list1 = Collections.synchronizedList(list);
        for (int i = 0; i < 10; i++) {
            new Thread(()->{
                while(list1.size()>0){
                    System.out.println(list1.remove(0));
                }
            }).start();
        }

    }
}
```
2,Vector实现

```java

import java.util.Vector;

public class TicketSeller02 {
    static Vector<String>vector= new Vector<>();
    static {
        for (int i = 1; i <11; i++) {
            vector.add("第--"+i+"张票");
        }
    }
    public static void main(String[] args) {
        for (int i = 0; i < 10; i++) {
            new Thread(()->{while (vector.size()>0){
                System.out.println(vector.remove(0));}
            }).start();
        }
    }
}

```
第三种
CopyOnWriteArrayList实现;

```java
public class TicketSeller02 {
    static CopyOnWriteArrayList<String> coa=new CopyOnWriteArrayList<>();
    static {
        for (int i = 1; i <11 ; i++) {
            coa.add("第--"+i+"张票");
        }
    }
    public static void main(String[] args) {     
        for (int i = 0; i < 10; i++) {
            new Thread(()->{while (coa.size()>0){
                System.out.println(coa.remove(0));}
            }).start();
        }

    }
}

```

上面的几个案例看似没说有什么问题,但是,
看一下下面的的代码------->>>>

```java
public class TicketSeller02 {
    static Vector<String>vector= new Vector<>();
    static {
        for (int i = 1; i <11; i++) {
            vector.add("第--"+i+"张票");
        }
    }
    public static void main(String[] args) {
        for (int i = 0; i < 10; i++) {
            new Thread(()->{
                while (vector.size()>0){
                try {
                    TimeUnit.MICROSECONDS.sleep(10);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(vector.remove(0));

                }
            }).start();
        }
}
```

报异常了,说明票已经卖完了,但是还有有线程在卖票,,所以对于Vector的Remove方法会报错;
![在这里插入图片描述](https://img-blog.csdnimg.cn/fb1c817743664b13a8545d3fe26baccf.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAR2F2aW5fTGlt,size_20,color_FFFFFF,t_70,g_se,x_16)
两个原子方法操做之间的代码并没有加锁.所以也会出现线程安全问题;

解决方法是在原子方法操做之间加锁

```java
 public static void main(String[] args) {
        for (int i = 0; i < 10; i++) {
            new Thread(()->{
                while (true){
                    synchronized (TicketSeller02.class) {
                        if(vector.size()<=0) break;
                        try {
                            TimeUnit.MICROSECONDS.sleep(10);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                System.out.println(vector.remove(0));
                }
            }).start();
        }
    }
}

```
在高并发情况下,可以考虑用Queue来实现类似于卖票这种操做;

```java

import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.TimeUnit;

public class TicketSeller03 {
    static Queue<String> queue= new ConcurrentLinkedQueue<>();
    static {
        for (int i = 1; i <11 ; i++) {
            queue.add("第--"+i+"张票");
        }
    }
    public static void main(String[] args) {
        for (int i = 0; i < 19; i++) {
            new Thread(()->{
           while(true){
               String poll = queue.poll();
               if(poll==null) break;
               try {
                   TimeUnit.MICROSECONDS.sleep(20);
               } catch (InterruptedException e) {
                   e.printStackTrace();
               }
               System.out.println(poll);
           }
            }).start();
        }
    }}

```

所以从最初的vector/stack到list再到queue



# 算法

## 斐波那契数列----
	斐波那契数列（Fibonacci sequence），又称黄金分割数列，因数学家莱昂纳多·斐波那契（Leonardo Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：0、1、1、2、3、5、8、13、21、34、……在数学上，斐波那契数列以如下被以递推的方法定义：F(0)=0，F(1)=1, F(n)=F(n - 1)+F(n - 2)（n ≥ 2，n ∈ N*）


[斐波那契数列的应用](https://baike.baidu.com/item/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/99145?fr=aladdin#4)

### 斐波那契数列的简单的代码实现
```java
import java.util.Scanner;

public class Test {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.println("请输入你想得到的斐波那契数列个数-----");
        int number= sc.nextInt();
int x=1;
int y=1;
int z=0;
        for (int i = 1; i <=number ; i++) {
            if(i==1||i==2){
                System.out.print(1+"\t");
            }else{
                z=x+y;
                x=y;
                y=z;
                System.out.print(z+"\t");
            }

        }

    }
}
```

## 百钱买百鸡

> 我国古代数学家张丘建在《算经》一书中曾提出过著名的“百钱买百鸡”问题，该问题叙述如下：鸡翁一，值钱五；鸡母一，值钱三；鸡雏三，值钱一；百钱买百鸡，则翁、母、雏各几何？
>
> 翻译过来，意思是公鸡一个五块钱，母鸡一个三块钱，小鸡三个一块钱，现在要用一百块钱买一百只鸡，问公鸡、母鸡、小鸡各多少只？

```java
public class Test {
    public static void main(String[] args) {
methodB();
    }
    /*公鸡一个五块钱，母鸡一个三块钱，小鸡三个一块钱，
    现在要用一百块钱买一百只鸡，问公鸡、母鸡、小鸡各多少只？*/

    public static  void methodB(){

        for (int i = 0; i <=20 ; i++) {
            for (int j = 0; j <=34; j++) {
                for (int k = 0; k <=300 ; k++) {
                    if((5*i+3*j+k/3)==100&&(i+j+k)==100&&k%3==0){
                        //System.out.println(i+"\t"+j+"\t"+k);
                        System.out.  printf("公鸡 %2d 只，母鸡 %2d 只，小鸡 %2d 只\n", i, j, k);
                    }
                }
            }

        }
    }

  }
```


##   排序算法

  基于比较的排序算法:
        BUB - 冒泡排序,
        SEL - 选择排序,
        INS - 插入排序,
        MER - 归并排序 (递归实现),
        QUI - 快速排序 (递归实现),
        R-Q - 随机快速排序 (递归实现).
    不基于比较的排序算法:
        COU - 计数排序,
        RAD - 基数排序.
        
冒泡排序---->>>选择排序----->插入排序
这三种排序算法最容易实现，但不是最有效的，因为它们的时间复杂度是O（N2)。

### 冒泡排序

1,如果元素大小关系不正确，交换这两个数（在本例中为a> b），
2,比较一对相邻元素（a，b），
3,重复步骤1和2，直到我们到达数组的末尾（最后一对是第（N-2）和（N-1）项，因为我们的数组从零开始）
4,到目前为止，最大的元素将在最后的位置。 然后我们将N减少1，并重复步骤1，直到N = 1

```java
//冒泡排序
    public static void maoPaoSort(int array[]){
//升序排列
        for (int i = 0; i < array.length-1; i++) {
            for (int j = 0; j <array.length-1-i  ; j++) {
//先假定第一个数最小;
                if(array[j]>array[j+1]){//如果第一个数大于它之后的数
                    int temp;//临时变量
                    temp=array[j];
                    array[j]=array[j+1];
                    array[j+1]=temp;
                }
            }
        }
        for (int i = 0; i < array.length; i++) {
            System.out.print(array[i]+"\t");
        }
    }
```

### 选择排序

给定 N 个项目和 L = 0 的数组，选择排序将：
1,在 [L ... N-1] 范围内找出最小项目 X 的位置，
2,用第 L 项交换X，
3,将下限 L 增加1并重复步骤1直到 L = N-2。



```java
//选择排序
    public  static void choiceSort(int array[]){
        for (int i = 0; i < array.length; i++) {
            for (int j = i+1; j < array.length; j++) {
                int temp;//临时变量
                if(array[i]>array[j]){
                   temp=array[i];
                   array[i]=array[j];
                   array[j]=temp;
                }

            }
        }
        for (int i = 0; i < array.length; i++) {
            System.out.print(array[i]+"\t");
        }
    }
```
