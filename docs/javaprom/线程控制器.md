# 线程控制器

## CountDownLatch

CountDownLatch类的基本信息

> public class CountDownLatch extends Object

允许一个或多个线程等待直到在其他线程中执行的一组操作完成的同步辅助。  CountDownLatch用给定的计数来初始化。

> 配合await方法阻塞，直到由于countDown()方法的调用而导致当前计数达到零，之后所有等待线程被释放，( 这是一个一次性的现象 - 计数无法重置。 如果您需要重置计数的版本，请考虑使用CyclicBarrier )。 

  CountDownLatch的用途------

> CountDownLatch用作一个简单的开/关锁存器，所有线程调用await在门口等待，直到被调用countDown()的线程打开。
> 一个CountDownLatch初始化N可以用来做一个线程等待，直到N个线程完成某项操作，或某些动作已经完成N次,在执行后续操作.

构造方法 

> CountDownLatch(int count)  
> 构造一个以给定计数 CountDownLatch CountDownLatch。

### 常用方法

void await() 
导致当前线程等到锁存器计数到零，除非线程是 interrupted 。  

boolean await(long timeout, TimeUnit unit) 
使当前线程等待直到锁存器计数到零为止，除非线程为 interrupted或指定的等待时间过去。  

void countDown() 
减少锁存器的计数，如果计数达到零，释放所有等待的线程。  

long getCount() 
返回当前计数。  

String toString() 
返回一个标识此锁存器的字符串及其状态。  

```java
public class CountDownTest {
    public static void main(String[] args) {
        methodsA();
        methodsB();
    }
    public static void methodsA(){
        Thread []threads= new Thread[3];//有3个线程
      /*  CountDownLatch 允许一个或多个线程等待直到在其他线程中执行的一组操作完成的同步辅助类。
        A CountDownLatch用给定的计数初始化。 await方法阻塞，直到由于countDown*/
        CountDownLatch cdl= new CountDownLatch(threads.length);//线程控制器--锁存器
        Lock lock=new ReentrantLock();
        for (int i = 0; i < threads.length; i++) {
            threads[i]= new Thread(()->{
                lock.lock();
                int result=0;
                for (int j = 0; j <=2 ; j++) {//执行这个循环
                    result+=j;
                    System.out.println(result);
                }
                lock.unlock();
                cdl.countDown();//执行完一次计数一次   -1
            }
            );
        }
        for (int i = 0; i < threads.length; i++) {//开启线程
            threads[i].start();
        }
        try {
         /*  await方法阻塞，直到由于countDown()方法的调用而导致当前计数达到零，
            之后所有等待线程被释放，并且任何后续的await 调用立即返回。*/

            cdl.await();//如果没有await方法阻塞.则输出语句先执行---即后续代码可能先执行
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("cdl结束");
    }
    public static void methodsB(){
        Thread []threads= new Thread[3];//有3个线程
        for (int i = 0; i < threads.length; i++) {
            threads[i]= new Thread(new Runnable() {
                @Override
                public void run() {
                    synchronized (this) {
                        int result = 0;
                        for (int j = 0; j <= 2; j++) {//执行这个循环
                            result += j;
                            System.out.println(result);
                        }
                    }
                }
            }
            );
        }
        for (int i = 0; i < threads.length; i++) {//开启线程
            threads[i].start();
           try {
                threads[i].join();//类比
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println("join结束");
    }

}

```

![在这里插入图片描述](https://img-blog.csdnimg.cn/e07d1708640445639f176bdc3e32ccd4.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81NDA2MTMzMw==,size_16,color_FFFFFF,t_70)如果没有锁存器,代码执行顺序上可能跟我们想要的不一样,用锁存器CountDownLatch与join()的区别就是CountDownLatch更加灵活,可以控制线程何时进行下一步;

await()与await(long timeout,TimeUnit unit)方法

```java
public void await()

           throws InterruptedException

public boolean await(long timeout,

                     TimeUnit unit)

              throws InterruptedException

```


从参数上就可以了解到异同点----返回值不一样

##### 相同点------

1,如果当前计数为零，则此方法立即返回。 
2,如果当前计数大于零，则当前线程将被禁用以进行线程调度，并处于休眠状态，直至发生两件事情之一： 

由于countDown()方法的调用，计数达到零;  
一些其他线程interrupts当前线程。

##### 异同点------

1,await(long timeout,
                     TimeUnit unit)指定的等待时间过去了也会立即返回,如果等待时间小于等于零,则根本就不会等待;
                     

## CyclicBarrier

CyclicBarrier类的基本信息

> public class CyclicBarrier extends Object

允许一组线程全部等待彼此达到共同屏障点的同步辅助。 循环阻塞在涉及固定大小的线程方的程序中很有用，这些线程必须偶尔等待彼此。 屏障被称为循环 ，因为它可以在等待的线程被释放之后重新使用。 
A CyclicBarrier支持一个可选的Runnable命令，每个屏障点运行一次，在派对中的最后一个线程到达之后，但在任何线程释放之前。 在任何一方继续进行之前，此屏障操作对更新共享状态很有用。 

> 通俗的讲就像是一辆车,不满员不发车;

构造方法 
            
​          

> CyclicBarrier(int parties) 
>
> 创建一个新的 CyclicBarrier ，当给定数量的线程（线程）等待它时，它将跳闸，并且当屏障跳闸时不执行预定义的动作。  

> CyclicBarrier(int parties, Runnable barrierAction) 
>
> 创建一个新的 CyclicBarrier，当给定数量的线程（线程）等待时，它将跳闸，当屏障跳闸时执行给定的屏障动作，由最后一个进入屏障的线程执行。

### 常用方法

int await() 
等待所有 parties已经在这个障碍上调用了 await 。  

int await(long timeout, TimeUnit unit) 
等待所有 parties已经在此屏障上调用 await ，或指定的等待时间过去。  

int getNumberWaiting() 
返回目前正在等待障碍的各方的数量。  

int getParties() 
返回旅行这个障碍所需的聚会数量。  

boolean isBroken() 
查询这个障碍是否处于破碎状态。  

void reset() 
将屏障重置为初始状态。  



```java

public class CyclicBarrierTest {
    public static void main(String[] args) {
        //CyclicBarrier(int parties, Runnable barrierAction)
        Lock lock = new ReentrantLock(true);//公平锁
        CyclicBarrier clb = new CyclicBarrier(5, new Runnable() {
            @Override
            public void run() {//满员之后
                System.out.println("线程数量够5了,可以发车了");
            }
        });
        Thread[] threads = new Thread[14];//14个线程
        for (int i = 0; i < threads.length; i++) {
            threads[i] = new Thread(() -> {
                try {
                    lock.lockInterruptibly();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                int result = 0;
                for (int j = 0; j < 3; j++) {
                    result += j;
                    System.out.println(result);
                }
                try {
                    lock.unlock();
                    clb.await();
                } catch (Exception e) {
                    e.printStackTrace();
                }


            });
        }

        for (Thread th:threads
             ) {
            th.start();
        }
        }
    }
    //其他方法----
  int numberWaiting = clb.getNumberWaiting();//此方法主要用于调试和断言。 
        System.out.println("当前正在等待的线程数量---"+numberWaiting);
        System.out.println("当前屏障是否被破坏----"+clb.isBroken());//
        System.out.println("当前屏障要求的数---"+clb.getParties());

```

![在这里插入图片描述](https://img-blog.csdnimg.cn/1d57d21c2d854f4db360d498d2c71b55.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81NDA2MTMzMw==,size_16,color_FFFFFF,t_70)

await()与await(long timeout,TimeUnit unit)方法

> public int await()
>           throws InterruptedException, BrokenBarrierException

> public int await(long timeout,TimeUnit unit) 
> throws InterruptedException, BrokenBarrierException,              TimeoutException

##### 相同点------

1,最后一个线程到达;  
2,当前线程为interrupts ; 
3,一些其他线程interrupts其他等待线程; 
4,其他一些线程在这个屏障上调用reset() 。 

##### 异同点------

1,await(long timeout,
                     TimeUnit unit)线程在等待屏障时超时,如果等待时间小于等于零,则根本就不会等待;

等待超时,与屏障损坏异常----
![在这里插入图片描述](https://img-blog.csdnimg.cn/ec6ad857dbd04d4b9bbf8ba4a3accc90.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81NDA2MTMzMw==,size_16,color_FFFFFF,t_70)

#### 其他注意事项

```java
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * @author : Gavin
 * @date: 2021/8/19 - 08 - 19 - 8:41
 * @Description: victory
 * @version: 1.0
 */
public class ReadWriteLockTest {
    static Lock lock= new ReentrantLock(true);
    public static void main(String[] args) {
        CyclicBarrier cls= new CyclicBarrier(3, new Runnable() {
            @Override
            public void run() {//满员之后---要么设置公平锁,要么设置成同步方法,否则会出现 其他非理想情况;
                //lock.lock();
                System.out.println("总结");
               // lock.unlock();
            }
        });
        Thread []threads= new Thread[10];
        for (int i = 0; i < threads.length; i++) {
            threads[i]= new Thread(()->{
                int result=0;
               lock.lock();
               System.out.println(result);
                try {
                    lock.unlock();
                    cls.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } catch (BrokenBarrierException e) {
                    e.printStackTrace();
                }
            });
        }
        for (int j = 0; j < 10; j++) {
            threads[j].start();
        }
    }
}

```

非理想情况截图-----
![在这里插入图片描述](https://img-blog.csdnimg.cn/ec827cee677e41e885ddb876c4bc971b.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81NDA2MTMzMw==,size_16,color_FFFFFF,t_70)



## Phaser

> 前几天群里收到了李二狗的婚礼邀请函,于是就有了以下问题----- 
> 婚礼的流程是怎样的?怎样用代码来展示?

先简单说一下婚礼流程------
第一阶段-----包含三个小阶段

> 人到了----arrivePerson()
> 门口坐着收份子钱的老大爷,--------giveMoney() //为了方便写代码,假设人齐了才能收份子钱;
>
> 将给份子钱的人记录在册,---------writeName()

第二阶段-----包含两个小阶段

> 检查人是否到齐,人到齐了开席-------checkNum()
> 可以write和check合并
> 吃饱了可以走了-------leavePer()

第三阶段----包含一个小阶段

> 新郎新娘入洞房--------intoHome()

并不是所有人都参加完毕婚礼所有阶段,客人们参加完前两个阶段就可以了;

代码可能与描述有些许不符的地方,请见谅.正事要紧........
再写代码之前所
> public class Phaser extends Object

一个可重复使用的同步屏障，功能类似于CyclicBarrier和CountDownLatch，但支持更灵活的使用。 


> Phaser()  
> 创建一个新的移相器，没有最初的注册方，没有父级和初始阶段数0。  
>
> Phaser(int parties)  
> 创建一个新的移相器与给定数量的注册无障碍方，没有父母和初始阶段0。   
> Phaser(Phaser parent)  
> 相当于 Phaser(parent, 0) 。  
>
> Phaser(Phaser parent, int parties)  与给定的父母和注册的无礼方的数量创建一个新的移相器。

#### 常用方法
int arrive() 
抵达这个移相器，而不用等待别人到达。  

int arriveAndAwaitAdvance() 
到达这个移相器，等待其他人。  

int arriveAndDeregister() ----
到达这个移相器并从其中注销，而无需等待别人到达。  
![在这里插入图片描述](https://img-blog.csdnimg.cn/00d54eede01d49acbde946fc69577634.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81NDA2MTMzMw==,size_16,color_FFFFFF,t_70)**----------------------------愿这对新人长长久久吧!!!----------------------------------**



int awaitAdvance(int phase) 
等待该相位器的相位从给定相位值前进，如果当前相位不等于给定相位值，则立即返回，或者该相位器被终止。  

> **/* awaitAdvance(int phase );
>             如果传入参数phase值和当前getPhase()方法返回值一样，
>            则在屏障处等待，否则继续向下面运行，有些类似于旁观者的作用，
>           当观察的条件满足了就等待，如果条件不满足，则程序向下继续运行。*/**


![在这里插入图片描述](https://img-blog.csdnimg.cn/7faebe974b6544a7886beb831749cd0b.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81NDA2MTMzMw==,size_16,color_FFFFFF,t_70)

int awaitAdvanceInterruptibly(int phase) ----**等待时中断则抛出异常**

等待该移相器的阶段从给定的相位值推进，如果在等待时 
InterruptedException则抛出 InterruptedException ，或者如果当前相位不等于给定的相位值或者该相位器被终止，则立即返回。  


int awaitAdvanceInterruptibly(int phase, long timeout, TimeUnit unit) --**等待时中断则抛出异常或者等待超时也会抛出异常**

等待该移相器的阶段从给定的相位值或给定的超时时间 InterruptedException到等待时抛出 InterruptedException ，如果当前相位不等于给定的相位值，则立即返回，或者该相位器被终止。  

![在这里插入图片描述](https://img-blog.csdnimg.cn/9ddca789cbd14c78a98108a570c84a62.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81NDA2MTMzMw==,size_16,color_FFFFFF,t_70)int bulkRegister(int parties) ------**简单些讲就是有几个线程参与此份工作;**
增加给定数量的新的有争议的派对到这个移相器。  

![在这里插入图片描述](https://img-blog.csdnimg.cn/9f4c5abbe89148ae98f90850d9b341b5.png)void forceTermination() 
强制此移相器进入终止状态。  
![在这里插入图片描述](https://img-blog.csdnimg.cn/77ef2cb50d3740ef8b289cab7d5c8fd3.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81NDA2MTMzMw==,size_16,color_FFFFFF,t_70)![在这里插入图片描述](https://img-blog.csdnimg.cn/9ac0e2f61f934446ac5b7f8c9968ea4f.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81NDA2MTMzMw==,size_16,color_FFFFFF,t_70)在图中以上方法取一个常用方法----- onAdvance(int phase, int registeredParties) 
**第一个参数是 阶段数,第二个参数是当前参加的线程数**

protected boolean onAdvance(int phase, int registeredParties) 


> 在即将进行的相位提前执行动作的可覆盖方法，并控制终止。  这种方法在派对推进这个移相器（当所有其他等待方休眠）的时候被调用。
> 如果此方法返回true ，则该移相器将在提前设置为最终终止状态，后续调用isTerminated()将返回true。
>
> 任何（未选中）通过调用此方法引发的异常或错误将传播给尝试推进此移相器的方，在这种情况下不会发生提前。 
>
> 该方法的参数提供了当前转换占优势的状态。
> 在onAdvance内对这个移相器引用到达，注册和等待方法的onAdvance是未指定的，不应该依赖。 
>
> 如果这个移相器是分层的相位器的成员，那么onAdvance仅在每个onAdvance的根onAdvance器上被调用。 
>
> 支持最常见的用例，此方法的默认实现返回true时注册方的数量已变为零作为党调用的结果arriveAndDeregister 。
> 您可以禁用此行为，从而通过覆盖此方法始终返回false ： 
>
>    Phaser phaser = new Phaser() { protected boolean onAdvance(int
> phase, int parties) { return false; } } 参数


![在这里插入图片描述](https://img-blog.csdnimg.cn/a6d974c481ad4adc91c807617ddd446c.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81NDA2MTMzMw==,size_16,color_FFFFFF,t_70)

代码案例

假设总共有十个人参加婚礼(包括新郎新娘)

```java
package weqwe;

import java.util.concurrent.Phaser;
import java.util.concurrent.TimeUnit;

public class JoinMarried {
	// 第一个参数表示有 几个阶段(小阶段), 第二个参数表示总公共有多少人参加
	static MarriedPhaser mps = new MarriedPhaser();

	static class Person implements Runnable {// 参加婚礼的人
		String name;

		public Person(String name) {
			super();
			this.name = name;
		}

		public static void MinSleep(int time) {
			try {
				/*A TimeUnit表示给定的粒度单位的持续时间，
				并且提供了跨单元转换的实用方法，
				并且在这些单元中执行定时和延迟操作。*/
				TimeUnit.MILLISECONDS.sleep(time);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}

		// 都是人.那就所有人先一视同仁
		public void arrivePerson() {
			/*
			 * try {//既然每个方法否都此段内容,提取为方法 Thread.sleep(100); } catch (InterruptedException e)
			 * { // TODO Auto-generated catch block e.printStackTrace(); }
			 */
			MinSleep(100);
			System.out.printf("%s 到了", name);
			System.out.println();
			
			mps.arriveAndAwaitAdvance();

		}

		public void receiveMoney() {

			MinSleep(100);
			if (!("新郎--李二狗".equals(name) || "新娘--赵小花".equals(name))) {
				System.out.printf("%s 交了份子钱一份", name);
				System.out.println();
			}
			mps.arriveAndAwaitAdvance();

		}

		public void writeAndcheckName() {

			MinSleep(100);
			if (!("新郎--李二狗".equals(name) || "新娘--赵小花".equals(name))) {
				System.out.printf("%s 记录在册--人已到齐,可以吃席", name);
				System.out.println();
			}
			/* awaitAdvance(int phase );
            如果传入参数phase值和当前getPhase()方法返回值一样，
           则在屏障处等待，否则继续向下面运行，有些类似于旁观者的作用，
          当观察的条件满足了就等待，如果条件不满足，则程序向下继续运行。*/
			mps.awaitAdvance(1);
			//mps.arriveAndAwaitAdvance();

		}

		public void leavePer() {

			MinSleep(100);
			if (!("新郎--李二狗".equals(name) || "新娘--赵小花".equals(name))) {
				System.out.printf("%s 离开了", name);
				System.out.println();

			}
			mps.arriveAndAwaitAdvance();
		}

		public void intoHome() {
			if ("新郎--李二狗".equals(name) || "新娘--赵小花".equals(name)) {
				MinSleep(100);
				System.out.printf("%s 入洞房", name);
				System.out.println();
				mps.arriveAndAwaitAdvance();
			} else {
				mps.arriveAndDeregister();//到达这个锁存器并从其中注销，而无需等待别人到达。
			}

		}

		@Override
		public void run() {
			// TODO Auto-generated method stub
			arrivePerson();
			receiveMoney();
			writeAndcheckName();
			leavePer();
			intoHome();
		}

	}

	public static void main(String[] args) {
		/*增加给定数量的新的有争议的派对到这个移相器。 
		如果持续调用onAdvance(int, int)
		正在进行中，则此方法可能会在返回之前等待完成。
		如果此移动设备有父母，而且指定的当事人数量大于零，
		并且此移动设备以前没有注册方，则该子版移动设备也向其父母注册。
		如果此移相器被终止，则尝试注册不起作用，并返回负值。*/
		//简单来讲就是有多少个线程来执行当前任务
		mps.bulkRegister(10);// 婚礼总共参加的人数(包括新郎和新娘)
		for (int i = 0; i < 8; i++) {// 抛除新娘新郎的其他人
			new Thread(new Person("Per" + i)).start();
		}
		new Thread(new Person("新郎--李二狗")).start();
		new Thread(new Person("新娘--赵小花")).start();

	}

	static class MarriedPhaser extends Phaser {//继承该类,以便覆写所需要的方法

		@Override // 覆写该方法
		protected boolean onAdvance(int phase, int registeredParties) {
			// TODO Auto-generated method stub
			switch (phase) {
			case 0:// 第一步----人到了

				System.out.println("所有人都到了,总计---" + registeredParties + "人");
				System.out.println();// 换行
				return false;
			case 1:

				System.out.println("所有人都给了份子钱并记录在册,总计--" + (registeredParties - 2) + "份");
				System.out.println();// 换行
				return false;

			case 2:

				System.out.println("所有人都吃饱了离开了,总计---" + (registeredParties-2) + "人");
				System.out.println();// 换行
				return false;
			case 3:

				System.out.println("婚礼结束,新郎新娘.....沐浴更衣" );
				System.out.println();// 换行
				return true;// 只有新郎新娘可以全程参加
			default:
				return true;

			}

		}

	}
}


```
结果如下
```bash
Per5 到了
Per4 到了
Per2 到了
Per3 到了
Per1 到了
Per0 到了
Per6 到了
新娘--赵小花 到了
Per7 到了
新郎--李二狗 到了
所有人都到了,总计---10人

Per0 交了份子钱一份
Per3 交了份子钱一份
Per4 交了份子钱一份
Per7 交了份子钱一份
Per2 交了份子钱一份
Per5 交了份子钱一份
Per6 交了份子钱一份
Per1 交了份子钱一份
所有人都给了份子钱并记录在册,总计--8份

Per4 记录在册--人已到齐,可以吃席
Per1 记录在册--人已到齐,可以吃席
Per6 记录在册--人已到齐,可以吃席
Per5 记录在册--人已到齐,可以吃席
Per2 记录在册--人已到齐,可以吃席
Per7 记录在册--人已到齐,可以吃席
Per0 记录在册--人已到齐,可以吃席
Per3 记录在册--人已到齐,可以吃席

Per6 离开了
Per7 离开了
Per3 离开了
Per0 离开了
Per4 离开了
Per1 离开了
Per5 离开了
Per2 离开了
所有人都吃饱了离开了,总计---8人

新娘--赵小花 入洞房
新郎--李二狗 入洞房
婚礼结束,新郎新娘.....沐浴更衣
```

未完待续.....
21年8月18日接续
接续-----\

```java

import java.util.concurrent.Phaser;
import java.util.concurrent.TimeUnit;

/**
 * @author : Gavin
 * @date: 2021/8/18 - 08 - 18 - 20:58
 * @Description: setTest
 * @version: 1.0
 */
public class WaterHotMachine {

    static Hot hot = new Hot();//引入一个线程锁存器

    public static void Minsleep(int time) {
        try {
            TimeUnit.SECONDS.sleep(time);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    static class Hot extends Phaser {
        @Override
        protected boolean onAdvance(int phase, int registeredParties) {
            switch (phase) {
                case 0:
                    Minsleep(2);
                    System.out.println("所有设备都已接入电源" + "总计" + registeredParties);
                    return false;
                case 1:
                    Minsleep(5);
                    System.out.println("所有设备检查完毕--一切正常" + "总计" + registeredParties);
                    return false;
                case 2:
                    Minsleep(10);
                    System.out.println("所有设备都已进入功能调试---" + "总计" + registeredParties);
                    return false;
                case 3:
                    Minsleep(20);
                    System.out.println("开始加热---" + registeredParties);
                    return true;
                default:
                    return true;
            }

        }
    }

    static class Machine implements Runnable {
        String name;

        public Machine(String name) {

            this.name = name;
        }


        public void PlugIn() {
            Minsleep(2);//插入后两秒开始进入就绪状态
            System.out.println("指示灯亮起");
            //第一个线程执行到这等待直到后续线程也执行到此
            hot.arriveAndAwaitAdvance();
        }

        public void Check() {
            Minsleep(3);
            System.out.println("检查设备是否正常");
            hot.arriveAndAwaitAdvance();
        }

        public void SwitchFunction() {
            Minsleep(8);
            System.out.println("功能选择--");
            hot.arriveAndAwaitAdvance();
        }

        public void MakeHotTea() {
            Minsleep(15);
            if ("美的电热水壶".equals(name) || "九阳电热水壶".equals(name)) {
                System.out.println("开始制作茶水");
               hot.arriveAndAwaitAdvance();
            }else{
                hot.arriveAndDeregister();
            }


        }

        @Override
        public void run() {//抽检调试茶叶机器
            PlugIn();
            Check();
            SwitchFunction();
            MakeHotTea();
        }
    }

    public static void main(String[] args) {
        hot.bulkRegister(12);//抽查12种点热水壶,其中只有两种为茶水壶
        //Thread []threads= new Thread[12];
        for (int i = 0; i < 10; i++) {
            new Thread(new Machine("电热水壶" + i)).start();
        }
        new Thread(new Machine("美的电热水壶")).start();
        new Thread(new Machine("九阳电热水壶")).start();
    }


}

```

```java
Picked up JAVA_TOOL_OPTIONS: -Dfile.encoding=UTF-8
指示灯亮起
指示灯亮起
指示灯亮起
指示灯亮起
指示灯亮起
指示灯亮起
指示灯亮起
指示灯亮起
指示灯亮起
指示灯亮起
指示灯亮起
指示灯亮起
所有设备都已接入电源总计12
检查设备是否正常
检查设备是否正常
检查设备是否正常
检查设备是否正常
检查设备是否正常
检查设备是否正常
检查设备是否正常
检查设备是否正常
检查设备是否正常
检查设备是否正常
检查设备是否正常
检查设备是否正常
所有设备检查完毕--一切正常总计12
功能选择--
功能选择--
功能选择--
功能选择--
功能选择--
功能选择--
功能选择--
功能选择--
功能选择--
功能选择--
功能选择--
功能选择--
所有设备都已进入功能调试---总计12
开始制作茶水
开始制作茶水
开始加热---2

Process finished with exit code 0
```


21.20.12新增内容

```java
package com.thread.gavin.ThreadDemo.company;
import java.util.Random;
import java.util.concurrent.Phaser;
import java.util.concurrent.TimeUnit;

//会议的规则
class MeetingRuler extends Phaser {
    @Override
    protected boolean onAdvance(int phase, int registeredParties) {
        switch (phase) {
            case 0:
                System.out.println("参加员工代表大会的人都到到齐了----总共到会" + (registeredParties) + "人");
                System.out.println();
                return false;
            case 1:
                System.out.println("参加中层领导会议的人都到齐了---总共到会" + (registeredParties) + "人");
                System.out.println();
                return false;
            case 2:
                System.out.println("参加高层领导会议的人都到齐了---总共到会" + registeredParties + "人");
                System.out.println();
                return true;

            default:
                return true;

        }

    }
}

/**
 * @author Gavin
 * @description 会议 10名员工代表(基层领导)5名中层领导,3名高层领导,
 * 其中员工代表只参加基层会议,---阶段1 18人
 * 中/高层领导参加中高层会议,---阶段2 8人
 * 高层领导/董事长参加高层会议,---阶段3 3人
 */
class People implements Runnable {

    static MeetingRuler mr = new MeetingRuler();
    String name;
    void miSleep(int time) {
        try {
            TimeUnit.SECONDS.sleep(time);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
    public People(String name) {
        this.name = name;
    }

    /**
     * @author Gavin
     * @description 参加基层会议
     */
    public void joinCommonMeet() {
        //会议准备阶段
        miSleep(1);
        System.out.printf("%s 参加了员工代表大会 \n", name);
        //到这里等待---等所有人完成才能继续下一个
        mr.arriveAndAwaitAdvance();
        //到齐了,会议进行ing
        miSleep(1);
    }
    /**
     * @author Gavin
     * @description 参加中层会议
     */
    public void joinMidMeet() {
        if (name.equals("ZC") || name.equals("GC")) {
            //会议准备阶段
            miSleep(2);
            System.out.printf("%s 参加了中层领导会议\n", name);
            //领导到这也是等待----所有人都齐了,进行下一个
            mr.arriveAndAwaitAdvance();
            //到齐了,会议进行ing
        }
    }
    /**
     * @author Gavin
     * @description 参加高层会议 joinMidMeet之后用按理应该剩下5个中层领导,3个高层领导
     */
    public void joinHighMeeting() {
        //会议准备阶段
        if (name.equals("GC")) {
            //  miSleep(1);
            System.out.printf("%s 参加了高层领导会议\n", name);
            mr.arriveAndAwaitAdvance();
            //到齐了,会议进行ing
            miSleep(5);
        } else {
            mr.arriveAndDeregister();
        }
    }
    @Override
    public void run() {
        joinCommonMeet();
        joinMidMeet();
        joinHighMeeting();
    }
}
/**
 * @author Gavin
 */
public class Meeting {
    public static void main(String[] args) {
        People.mr.bulkRegister(18);
        Thread[] threads = new Thread[18];
        for (int i = 0; i < 18; i++) {
            if (i>=0&&i < 10)
                threads[i] = new Thread(new People("YG"));
            if (i>=10&&i < 15)
                threads[i] = new Thread(new People("ZC"));
            if (i>=15&&i < 18)
                threads[i] = new Thread(new People("GC"));
        }
        for (int i = 0; i < threads.length; i++) {
            threads[i].start();
        }
    }
}

```

重点理解arriveAndDeregister(),什么时候注销,如果有多个阶段多个筛选,那么只需要在最后一个阶段给注销掉,如果在其他阶段注销会提示异常
![在这里插入图片描述](https://img-blog.csdnimg.cn/4476635e4bcf4789894953e8491c523e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAR2F2aW5fTGlt,size_20,color_FFFFFF,t_70,g_se,x_16)

```java
java.lang.IllegalStateException: Attempted arrival of unregistered party for com.thread.gavin.ThreadDemo.company.MeetingRuler@63610ff0[phase = 1 parties = 0 arrived = 0]
```
![在这里插入图片描述](https://img-blog.csdnimg.cn/a8b38d7b539c4436878e198f049a2392.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAR2F2aW5fTGlt,size_20,color_FFFFFF,t_70,g_se,x_16)



## 可重入锁与读写锁

啥也不说,直接上代码

```java

import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

/**
 * @author : Gavin
 * @date: 2021/8/19 - 08 - 19 - 8:41
 * @Description: victory
 * @version: 1.0
 */
public class ReadWriteLockTest {
//    准备读写锁
   static Lock lock= new ReentrantLock(true);
static ReadWriteLock ReadWriteLock=new ReentrantReadWriteLock();//读写锁实例
static Lock readLock   =ReadWriteLock.readLock();//readLock方法返回值为Lock
static Lock writeLock=ReadWriteLock.writeLock();//writeLock()返回值为Lock
//读取的数据与修改的数据
static String name="HelloWorld";
    public static void main(String[] args) {
      //开启读线程
        Thread []threads= new Thread[10];
        for (int i = 0; i < 10; i++) {
            threads[i]= new Thread(new Runnable() {
                @Override
                public void run() {
readFunc(lock);
                }
            });
        }
        for (Thread th:threads
             ) {
            th.start();
        }
        //开启写线程
        Thread []th= new Thread[2];
        for (int i = 0; i < 2; i++) {
            th[i]= new Thread(()->{
                writeFunc(lock,"你好世界");
            });
        }
        for (Thread th1:th
             ) {
            th1.start();
        }

    }
    static void SleepMethod(int time){
        try {
            TimeUnit.SECONDS.sleep(time);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }


    }
    public static void readFunc(Lock lock){//读的时候加锁,以便禁止写入
        lock.lock();
        SleepMethod(1);
        System.out.println("读取的值为--"+name );
        lock.unlock();
    }
    public static void writeFunc(Lock lock ,String newName){
        lock.lock();
        SleepMethod(3);
        name= newName;
        SleepMethod(1);
        System.out.println("正在写入....");
        System.out.println("写入的值为"+name);
       lock.unlock();
    }
}

```

```java

import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

/**
 * @author : Gavin
 * @date: 2021/8/19 - 08 - 19 - 8:41
 * @Description: victory
 * @version: 1.0
 */

public class ReadWriteLockTest  {
    //    准备读写锁
    static Lock lock = new ReentrantLock(true);
    static ReadWriteLock ReadWriteLock = new ReentrantReadWriteLock();//读写锁实例
    static Lock readLock = ReadWriteLock.readLock();//readLock方法返回值为Lock
    static Lock writeLock = ReadWriteLock.writeLock();//writeLock()返回值为Lock
    //读取的数据与修改的数据
    static String name = "HelloWorld";
    static CyclicBarrier clb = new CyclicBarrier(10);
static long end=0;
static long start=0;
    public static void main(String[] args) {

        //开启读线程
        Thread[] threads = new Thread[10];
        for (int i = 0; i < 10; i++) {
            threads[i] = new Thread(new Runnable() {

                @Override
                public void run() {
                   
                    readFunc(readLock);
                    try {
                        clb.await();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    } catch (BrokenBarrierException e) {
                        e.printStackTrace();
                    }
                   
                }
            });

        }
        for (Thread th : threads
        ) {

            th.start();


        }
        //开启写线程
        Thread[] th = new Thread[2];
        for (int i = 0; i < 2; i++) {
            th[i] = new Thread(() -> {
                writeFunc(writeLock, "你好世界");

            });
        }
        for (Thread th1 : th
        ) {
            th1.start();
        }

    }

    static void SleepMethod(int time) {
        try {
            TimeUnit.SECONDS.sleep(time);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }


    }

    public static void readFunc(Lock lock) {//读的时候加锁,以便禁止写入
        lock.lock();
        SleepMethod(1);
        System.out.println("读取的值为--" + name);
        lock.unlock();
    }

    public static void writeFunc(Lock lock, String newName) {
        lock.lock();
        SleepMethod(3);
        name = newName;
        SleepMethod(1);
        System.out.println("正在写入....");
        System.out.println("写入的值为" + name);
        lock.unlock();
    }


}
```

分析后可以发现读锁如果是使用Lock锁则只能一个线程进行操作,其他线程拿不到该锁就会处于等待状态,比较浪费时间,如果换成读锁

下面是两种锁的情况下用时检测程序-----

```java

public class RWtest {
    //    准备读写锁
    static Lock lock = new ReentrantLock(true);
    static ReadWriteLock ReadWriteLock = new ReentrantReadWriteLock();//读写锁实例
    static Lock readLock = ReadWriteLock.readLock();//readLock方法返回值为Lock
    static Lock writeLock = ReadWriteLock.writeLock();//writeLock()返回值为Lock
    static String name = "HelloWorld";
    static long start = 0;
    static long end = 0;
    static PhraserTest PT = new PhraserTest();

    static void SleepTime(int T) {
        try {
            TimeUnit.SECONDS.sleep(T);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    static class PhraserTest extends Phaser {
        @Override
        protected boolean onAdvance(int phase, int registeredParties) {
            switch (phase) {
                case 0:

                    System.out.println("都准备开始读了--" + registeredParties);
                    return false;
                case 1:
                    System.out.println("都读取完毕了--" + registeredParties);
                    return false;
                case 2:
                    System.out.println("读取用时--" + (end - start));
                    return false;
                case 3:
                    System.out.println("都准备开始写了--" + registeredParties);
                    return false;
                case 4:
                    System.out.println("都写完了--" + registeredParties);
                    return false;
                case 5:
                    System.out.println("写入用时--" + (end - start));
                    return true;
                default:
                    return true;
            }
        }
    }

    static class NoteBook implements Runnable {
        static String str;

        public NoteBook(String str) {
            this.str = str;
        }

        static void startRead() {
            lock.lock();
            start = System.currentTimeMillis();
            lock.unlock();
            PT.arriveAndAwaitAdvance();
        }

        static void read(Lock lock) {
            lock.lock();
            SleepTime(1);
            System.out.println("读取的值为--" + name);
            lock.unlock();
            PT.arriveAndAwaitAdvance();
        }

        static void endRead() {
            lock.lock();
            end = System.currentTimeMillis();
            lock.unlock();
            PT.arriveAndAwaitAdvance();
        }

        static void startWrite() {
            lock.lock();
            start = System.currentTimeMillis();
            lock.unlock();
            PT.arriveAndAwaitAdvance();

        }

        static void write(Lock lock, String newName) {

            lock.lock();
            SleepTime(1);
            name = newName;
            System.out.println("正在修改....");
            SleepTime(1);
            System.out.println("修改后的值为" + name);
            lock.unlock();
            PT.arriveAndAwaitAdvance();
        }

        static void endWrite() {
            lock.lock();
            end = System.currentTimeMillis();
            lock.unlock();
            PT.arriveAndAwaitAdvance();
        }

        @Override
        public void run() {
            startRead();
            read(readLock);
            endRead();
            startWrite();
            write(writeLock, "你好,世界");
            endWrite();
        }
    }

    public static void main(String[] args) {
        PT.bulkRegister(20);
        for (int i = 0; i < 20; i++) {
            new Thread(new NoteBook("学生")).start();
        }
    }
}

```


![](C:\Users\Gavin\Pictures\Camera Roll\16.png)

> 主要是读锁,可以一起读,写锁不行,不能一起写;


回顾一下CountDownLatch

```java
package com.thread.gavin.ThreadDemo.company;

import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

public class CountDownLatchDemoTime {
    static  long start =0;
    static long end  = 0;
    //假设有一百个现车给来读取
    //准备不同的锁

    public static  void StartRead(Lock lock){
//        开始读了
        lock.lock();
        try {
            TimeUnit.SECONDS.sleep(1);

        } catch (InterruptedException e) {
            e.printStackTrace();
        }finally {
            lock.unlock();
        }
    }
    public static void main(String[] args) {
        final Lock lock = new ReentrantLock();
        ReadWriteLock readWriteLock= new ReentrantReadWriteLock();
        Lock readLock= readWriteLock.readLock();
        Thread []threads= new Thread[5];
    CountDownLatch cdl= new CountDownLatch(threads.length);
start=System.currentTimeMillis();
        for (int i = 0; i <threads.length ; i++) {
           threads[i]= new Thread(()->{
               //读取
               StartRead(readLock);
               cdl.countDown();
            });
        }
        for (Thread t :
                threads) {
            t.start();
        }
        try {
            cdl.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
      end=System.currentTimeMillis();
        System.out.println(end-start);
    }
}

```
![在这里插入图片描述](https://img-blog.csdnimg.cn/da4bff9350de4732ad9bcc1629cadcf8.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAR2F2aW5fTGlt,size_20,color_FFFFFF,t_70,g_se,x_16)在来回顾----CyclicBarrier

```java
package com.thread.gavin.ThreadDemo.company;

import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

public class CyclicReadLockTime {
    static  long start =0;
   static  long end= 0;
    public static void ReadN(Lock lock){
        try {
            lock.lock();
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }finally {
            lock.unlock();
        }
    }
    public static void main(String[] args) {

        Lock lock= new ReentrantLock();
        ReadWriteLock readWriteLock= new ReentrantReadWriteLock();
        Lock readLock=readWriteLock.readLock();
        CyclicBarrier clb= new CyclicBarrier(10, new Runnable() {

            @Override
            public void run() {
                end=System.currentTimeMillis();
                System.out.println("读用时---"+(end-start));
            }
        });
        Thread[]threads= new Thread[10];

        for (int i = 0; i <threads.length ; i++) {
            threads[i]= new Thread(()->{
                ReadN(readLock);
                try {
                    clb.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } catch (BrokenBarrierException e) {
                    e.printStackTrace();
                }
            });
        }
        start=System.currentTimeMillis();
        for (Thread tt:
             threads) {
            tt.start();
        }

    }
}

```
![在这里插入图片描述](https://img-blog.csdnimg.cn/325c8117b27849eda209c9adb5168c9e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAR2F2aW5fTGlt,size_20,color_FFFFFF,t_70,g_se,x_16)






## Semaphore
**Semaphore** 
public class Semaphore extends Object implements Serializable 

> 一个计数信号量。 在概念上，信号量维持一组许可证。 如果有必要，每个acquire()都会阻塞，直到许可证可用，然后才能使用它。
> 每个release()添加许可证，潜在地释放阻塞获取方。 但是，没有使用实际的许可证对象;
> Semaphore只保留可用数量的计数，并相应地执行。  信号量通常用于限制线程数，而不是访问某些（物理或逻辑）资源。



**构造方法** 
            
Semaphore(int permits) 
创建一个 Semaphore与给定数量的许可证和非公平公平设置。  

Semaphore(int permits, boolean fair) 
创建一个 Semaphore与给定数量的许可证和给定的公平设置。  

**默认boolean fair 的值为false**

> 当设置为false时，此类不会保证线程获取许可的顺序,当设置为true时.按照先进先出的原则--------通常，用于控制资源访问的信号量应该被公平地初始化，以确保线程没有被访问资源。 当使用信号量进行其他类型的同步控制时，非正常排序的吞吐量优势往往超过公平性。


![在这里插入图片描述](https://img-blog.csdnimg.cn/8f4b13d557b64e618ae407e80294aaa4.png)


### 常用方法
void acquire() 
从该信号量获取许可证，阻止直到可用，或线程为 interrupted 。  

> 如果没有可用的许可证，那么当前线程将被禁用以进行线程调度，并且处于休眠状态，直至发生两件事情之一： 
>
> 一些其他线程调用此信号量的release()方法，当前线程旁边将分配一个许可证; 要么  一些其他线程interrupts当前线程。
> void acquire(int permits)  从该信号量获取给定数量的许可证，阻止直到所有可用，否则线程为 interrupted
> 。
>
> 具体的说就是acquire()方法就是获得许可证,获得许可证后，如果还有可用的许可证并立即返回，并将可用许可证数量减少一个。当然也可以一次获取多个许可证;

void release() 
释放许可证，将其返回到信号量。  

void release(int permits) 
释放给定数量的许可证，将其返回到信号量。  

> release()方法释放掉以获得的许可证-------即恢复原来的许可证数量;

boolean tryAcquire() 
从这个信号量获得许可证，只有在调用时可以使用该许可证。  

boolean tryAcquire(int permits) 
从这个信号量获取给定数量的许可证，只有在调用时全部可用。  

boolean tryAcquire(int permits, long timeout, TimeUnit unit) 
从该信号量获取给定数量的许可证，如果在给定的等待时间内全部可用，并且当前线程尚未 interrupted 。 

> tryAcquire() 尝试获得许可证,跟 lock.tryLock()方法类似


先看代码---再摸索学习;


代码的大致逻辑是-----

> 好多线程访问同一个数据,但是线程太多的话,服务器有压力 需要对访问的线程数量做出限制;

```java

import java.util.concurrent.Semaphore;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
public class SeaphoreTest {
    static int TicketNum = 50;//50张票
   static Semaphore sp = new Semaphore(4, true);//
   static  Lock lock= new ReentrantLock(true);

static void BuyTicket(){
    //lock.lock();
    if (TicketNum > 0) {
        try {
            //只有四个人可以同时买票
            sp.acquire();
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName() + "抢到了第" + (TicketNum--) + "张票");
        sp.release();
        //lock.unlock();

    }
}
    public static void main(String[] args) {

//        Semaphore sp= new Semaphore(5,true);
        Thread[] threads = new Thread[2];//2个窗口
        for (int i = 0; i < 2; i++) {
            threads[i] = new Thread(() -> {//每个窗口有50人在排队抢票
                for (int j = 0; j < 50; j++) {
                    BuyTicket();
                }
            });

        }
        for (int i = 0; i < 2; i++) {
            threads[i].start();
        }
Thread []threads1= new Thread[3];
        for (int i = 0; i < 3; i++) {
            threads1[i] = new Thread(() -> {//每个窗口有50人在排队抢票
                for (int j = 0; j < 50; j++) {
                        BuyTicket();
                }
            });

        }
        for (int i = 0; i < 3; i++) {
            threads1[i].start();
        }
    }
}

```
执行后会发现----
![在这里插入图片描述](https://img-blog.csdnimg.cn/afa0eb515d704b5c990bf40550a86f31.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81NDA2MTMzMw==,size_16,color_FFFFFF,t_70)

![在这里插入图片描述](https://img-blog.csdnimg.cn/14844625869d474da67c84e4874e19ac.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81NDA2MTMzMw==,size_16,color_FFFFFF,t_70)
总结-----
1,Semaphore 虽然可以控制线程的并发量,但是不能保证线程安全;
如果给数据加上锁就会使得控制线程的目的失效,
2,对于公共数量上的操作一定要注意

下面模拟一个共享案例-----

假如再一个小饭馆的洗手间中只有两个坑位,碰巧四个人一起去洗手间,奈何只有两个坑位,即同时只有两个人能进行那啥........


模拟代码如下-----

```java

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.concurrent.Semaphore;

public class SeaphoreTest {
   static Semaphore sp= new Semaphore(2);
   static  class Person implements Runnable {

        private String name;

        public Person(String name) {
            this.name = name;
        }

        @Override
        public void run() {
            SimpleDateFormat sdf= new SimpleDateFormat("HH:mm:ss.SSS");

            //进入方便之前要获得许可证
            try {
                sp.acquire();//
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(name+"在"+sdf.format(new Date())+"进入方便");
            try {
                Thread.sleep(1000);//方便ing
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(name+"在"+sdf.format(new Date())+"结束方便");
            sp.release();
        }
    }
    public static void main(String[] args) {
Thread threads[]= new Thread[4];
        for (int i = 0; i < 4; i++) {
            threads[i]= new Thread(new Person("Per"+i));
        }
        for (Thread t:threads
             ) {
            t.start();
        }

    }
}

```
![在这里插入图片描述](https://img-blog.csdnimg.cn/52a776d6ae144851ad72672226ef89ba.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81NDA2MTMzMw==,size_16,color_FFFFFF,t_70)


公平锁和非公平锁的区别---
非公平锁下-----必须要许可证都是放完毕后,剩下的线程再重新竞争许可证的获得权,尽管有的线程已经等待好久了还是要和刚刚来的线程一起竞争;

公平锁下-----按照排队顺序,等待好久的线程比刚来的线程要先获得该许可证;

下面看一下源码是怎样实现的----

![](C:\Users\Gavin\Pictures\Camera Roll\17.png)

> 粗略分析一下,大致源码意思就是   第一次取得许可证底层源码的返回值为1,所有许可证被取走后.再来取的就要等待---阻塞状态,    
> 底层时靠着节点来维护线程队列的;
>

> 所以也就可以解释了公平锁的原理-------等待时间长的概念,先进先出,当前某个线程的许可证被释放,当前线程的下一个节点线程获得该许可证;

```java
package com.thread.gavin.ThreadDemo.company;

import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;

//一个洗手间同时能供三个人上厕所,现在呢有8个人要去厕所
class Per implements Runnable{
String name;

    public Per(String name) {
        this.name = name;
    }
    static Semaphore semaphore= new Semaphore(3,true);
    @Override
    public void run() {

        try {
            semaphore.acquire();
            System.out.printf("%s 在厕所\n",name);
            TimeUnit.SECONDS.sleep(5);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }finally {
            System.out.printf("%s 离开了厕所\n",name);
            semaphore.release();
        }
    }
}

public class SemaphoreDemo {
    public static void main(String[] args) {

Thread[]threads= new Thread[8];
        for (int i = 0; i <8 ; i++) {
            threads[i]= new Thread(new Per("PER"+i));
        }
        for (Thread t:
             threads) {
           t.start();
        }
    }
}

```


## Exchanger

public class Exchanger<V> extends Object--------   泛型类

> 线程可以在**成对内配对和交换元素的同步点**。
> 每个线程在输入exchange方法时提供一些对象，**与合作者线程匹配，并在返回时接收其合作伙伴的对象。**
> 交换器可以被视为一个的双向形式SynchronousQueue 。 交换器在诸**如遗传算法和管道设计的应用中可能是有用的。**

```java
 static Exchanger <String> ex= new Exchanger<>(); 
```

**构造方法**


 Exchanger() 
创建一个新的交换器。 


### 常用方法
V exchange(V x) 
等待另一个线程到达此交换点（除非当前线程为 interrupted ），然后将给定对象传输给它，接收其对象作为回报。  

V exchange(V x, long timeout, TimeUnit unit) 
等待另一个线程到达此交换点（除非当前线程为 interrupted或指定的等待时间已过），然后将给定对象传输给它，接收其对象作为回报。  

```java
package setTest;

import java.util.concurrent.Exchanger;

/**
 * @author : Gavin
 * @date: 2021/8/20 - 08 - 20 - 20:11
 * @Description: setTest
 * @version: 1.0
 */

public class ExchangeTest {
    static Exchanger <String> ex= new Exchanger<>();
    static class Gailun extends Thread{
       private String str="苹果";
        @Override
        public void run() {
            try {
                System.out.println("盖伦原来有一个"+str);

                Thread.sleep(1000);
             str=   ex.exchange(str);//执行到这里阻塞,等待有缘人
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("盖伦与皇子交换后--"+Thread.currentThread().getName()+"现在有了"+str);
        }
    }
    static class Huangzi extends Thread{
              String str="桃子";
        @Override
        public void run() {
            try {
                System.out.println("皇子原来有一个"+str);
                Thread.sleep(1000);
               str= ex.exchange(str);//执行到这里阻塞,等待有缘人
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("皇子与盖伦交换后--"+Thread.currentThread().getName()+"现在有了"+str);
        }
    }
    public static void main(String[] args) {
      Gailun gl=new Gailun();
              gl.setName("盖伦");
             gl.start();
      Huangzi hz=new Huangzi();
      hz.setName("皇子");
hz.start();
    }
}

```
![在这里插入图片描述](https://img-blog.csdnimg.cn/adf647e348164b8a9956e8403ea633b1.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81NDA2MTMzMw==,size_16,color_FFFFFF,t_70)
具体一个应用就是两个线程之间来交换东西,复杂一些的时交换将所需要的包装成类进行交换;

API中给了一个交换缓冲区的案例,

**使用Exchanger在线程之间交换缓冲区的类的Exchanger ，以便填充缓冲区的线程在需要时将其清空，将已填充的线程移交给清空缓冲区的线程。**

```java
class FillAndEmpty { 
Exchanger<DataBuffer> exchanger = new Exchanger<DataBuffer>(); 
DataBuffer initialEmptyBuffer =.......


class FillingLoop implements Runnable {
 public void run() { 
 DataBuffer currentBuffer =

try { 
while (currentBuffer != null) { 
addToBuffer(currentBuffer); 
if (currentBuffer.isFull()) 
currentBuffer = exchanger.exchange(currentBuffer);
 } 
 } catch (InterruptedException ex)
................
```
需要的话可以查一下API

# 线程阻塞的方式

再学习LockSupport之前,我们学过了能让线程阻塞的几种方式-----


## 方式一--Thread.join()

```java

public class LearnTest {
    public static void main(String[] args) {
        Thread thread=new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i <10; i++) {
                    System.out.println("Thread---"+i);
                }
            }
        });
        new Thread(()->{
            for (int i = 0; i < 10; i++) {
                if(i==4){
                    thread.start();
                    try {
                        thread.join();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }

                }
                System.out.println("打印---"+i);
            }
        }).start();

    }
}

```
当匿名线程在打印0-4之后,线程thread插队进来,这时候匿名线程就处于阻塞状态(等待).直至thread线程运行完毕;
![在这里插入图片描述](https://img-blog.csdnimg.cn/8ea3213c16d944878c19e377a2c479a3.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81NDA2MTMzMw==,size_16,color_FFFFFF,t_70)
## 方式二--Object中的wait()方法----阻塞  

```java

/**
 * @author : Gavin
 * @date: 2021/8/21 - 08 - 21 - 10:02
 * @Description: ReviewDay.zong
 * @version: 1.0
 */
public class MobilePro {
    private String brand;//手机品牌
    private String kind;//型号
    private int price;// 手机价钱
boolean flag=false;//默认还没有生产
    public String getBrand() {
        return brand;
    }

    public void setBrand(String brand) {
        this.brand = brand;
    }

    public String getKind() {
        return kind;
    }

    public void setKind(String kind) {
        this.kind = kind;
    }

    public int getPrice() {
        return price;
    }

    public void setPrice(int price) {
        this.price = price;
    }
    public  synchronized void setMobileInfo(String brand,String kind,int price){//生产手机产品
        this.brand=brand;
        this.kind=kind;
        this.price=price;
        //生产要求是如果有就停止生产,没有则生产
        if(flag==true){//如果有则停止生产
            try {
                wait();//即wait()下面的代码不执行----是if代码段之外的部分而不是else的部分
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

        }

        //wait()下面的代码
        //如果没有则开始生产
        this.setBrand(brand);
        this.setKind(kind);
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        this.setPrice(9999);
        try {
            Thread.sleep(10);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("我生产了--"+this.brand+"型号--"+this.kind+"价钱--"+this.price);
        //生产完毕后通知消费者可以取货了
        flag=true;
        notify();


    }
    public synchronized void getMobileInfo(){//消费生产的手机产品
        if(flag==false){//如果无货,则等待
            //没有货的话---等待
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

        }
       //如果有货,则消费
        System.out.println("我消费了--"+this.brand+"品牌--"+this.kind+"型号--"+"价钱--"+price);
        //消费完毕,通知生产者生产
        flag=false;
        notify();

    }
}

```

```java

class Consumer implements Runnable {
private MobilePro mp;

    public Consumer(MobilePro mp) {
        this.mp = mp;
    }

    @Override
    public void run() {
        for (int i = 0; i < 10; i++) {
            mp.getMobileInfo();
        }
    }
}
class Producer implements Runnable{
    private MobilePro mp;

    public Producer(MobilePro mp) {
        this.mp = mp;
    }

    @Override
    public void run() {
       
        for (int i = 0; i < 10; i++) {
            if(i%2==0){
                mp.setMobileInfo("华为","P50",9999);
            }
            else{
                mp.setMobileInfo("小米","MIX4",9998);
            }
        }
    }
}

public class WaitNotifyTest {
    public static void main(String[] args) {
        MobilePro mp = new MobilePro();
        new Thread(new Consumer(mp)).start();
        new Thread(new Producer(mp)).start();
    }
}


```

> wait()方法被唤醒后并不能保持持有该锁,所以必须要在synchronized代码块中食用,notify()方法是用来唤醒被wait()的线程;
> 这种方式只适用于线程A与线程B 之间,如果有多个生产者和消费者的情况就不适用了.具体原理如下图

![在这里插入图片描述](https://img-blog.csdnimg.cn/1078cdb1808d4f868ce659511ae31951.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81NDA2MTMzMw==,size_16,color_FFFFFF,t_70)
代码验证如下----一两个生产者,一个消费者为例----
再上述代码中再加入一个生产者
运行结果中出现了生产者生产完毕后通知了生产者生产的情况;
![在这里插入图片描述](https://img-blog.csdnimg.cn/e2fa1e0a469c4423b3133957440ab484.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81NDA2MTMzMw==,size_16,color_FFFFFF,t_70)

> 要解决多个生产者多个消费者的问题存在,需要用Lock锁来解决

## 方式三--Lock接口实现类中的wait()方法----阻塞  
线程同步的常用方式是 :
synchronized  同步
lock()  unlock() 实现同步



所以以上代码只需做如下修改----

**> 1,将synchronized 锁换成 lock锁 
**> 2,将Object中的wait()方法换成Condition中的await()方法****

![在这里插入图片描述](https://img-blog.csdnimg.cn/089f0793e4094c7fb6519a958416a289.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81NDA2MTMzMw==,size_16,color_FFFFFF,t_70)
### Object中的wait()方法
public final void wait() throws InterruptedException

导致当前线程等待，直到另一个线程调用该对象的notify()方法或notifyAll()方法。 

> 当前的线程必须拥有该对象的显示器。
> 该线程释放此监视器的所有权，并等待另一个线程通知等待该对象监视器的线程通过调用notify方法或notifyAll方法notifyAll 。
> 然后线程等待，直到它可以重新获得监视器的所有权并恢复执行。

boolean await(long time, TimeUnit unit)  throws InterruptedException

使当前线程等待直到发出信号或中断，或指定的等待时间过去。 

> **wait()方法必须配套notify()/notifyAll()来使用**

public final void notify()

唤醒正在等待**对象**监视器的**单个线程**。 如果任何线程正在等待这个对象，其中一个被选择被唤醒。 选择是任意的，并且由实施的判断发生。 线程通过调用wait方法之一等待对象的监视器。 

> **唤醒的线程将无法继续，直到当前线程放弃此对象上的锁定为止。**
> **唤醒的线程将以通常的方式与任何其他线程竞争，这些线程可能正在积极地竞争在该对象上进行同步;**
> **例如，唤醒的线程在下一个锁定该对象的线程中没有可靠的权限或缺点。** 
>

> **该方法只能由作为该对象的监视器的所有者的线程调用。 线程以三种方式之一成为对象监视器的所有者：** 
>
> **通过执行该对象的同步实例方法。**  
> **通过执行在对象上synchronized synchronized语句的正文。** 
> **对于类型为Class,的对象，通过执行该类的同步静态方法。  一次只能有一个线程可以拥有一个对象的显示器**

public final void notifyAll()

唤醒正在等待**对象**监视器的**所有线程**。 线程通过调用wait方法之一等待对象的监视器。 

> 唤醒的线程将无法继续，直到当前线程释放该对象上的锁。
> **唤醒的线程将以通常的方式与任何其他线程竞争，这些线程可能正在积极地竞争在该对象上进行同步;**
> 例如，唤醒的线程在**下一个锁定该对象**的线程中**不会有可靠的特权**或缺点。


### Condition中的await()方法
void await()  throws InterruptedException
导致当前线程等待，直到它被信号或中断。

与此相关的**锁**是**原子释放**的，当前线程因**线程调度**目的**而**禁用，并**处于休眠状态**，直到发生四件事之一：

1,其他一些线程调用该方法的**signal(）方法**，当前线程恰好被选为要唤醒的线程,或Condition
2,其他一些线程调用信号**signalAll（）**方法：或Condition
3,其他一些线程中断当前线程，并支持线程中断,或者"虚假的线程唤醒"发生。
在所有情况下，在此方法返回之前，当前线程必须重新获取与此条件相关的锁。当线程返回时，保证会**保持此锁**。


> **await()方法需要与signal()/signalAll()配套使用**


void signal()

唤醒一个等待线程。 

如果任何线程正在等待此条件，则选择一个线程进行唤醒。 那个线程必须在从await之前重新**获取锁**。 

void signalAll()唤醒所有等待线程。 

如果任何线程正在等待这个条件，那么它们都被唤醒。 每个线程必须重新获取锁，才能从await返回。 

实施注意事项 ---如果不配合lock.lock()/lock.unlock()使用就会抛出异常;

当调用此方法时，实现可能（通常是）要求当前线程保持与此Condition的锁。 执行必须记录此前提条件，如果不保持锁定，则采取任何措施。 通常情况下，一个异常如IllegalMonitorStateException将被抛出。 

![在这里插入图片描述](https://img-blog.csdnimg.cn/44f5f3e5db02417f8670e06bd6188a02.png)


## 方式四--CountDownLatch----阻塞  

```java

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CountDownLatch;

/**
 * @author : Gavin
 * @date: 2021/8/21 - 08 - 21 - 12:17
 * @Description: ReviewDay
 * @version: 1.0
 */

public class CountDownLatchTest01 {
    public static void main(String[] args) {
       //有100个线程
        List<Thread> test = new ArrayList<>(100);
        System.out.println(test.size());
        List<Thread> list = new ArrayList<>();
        CountDownLatch cdl = new CountDownLatch(100);//计数器--门闩
        for (int i = 0; i < 100; i++) {//添加了100个对象
            list.add(new Thread(()->{
                for (int j = 0; j < 521; j++) {
                    System.out.println("打印--"+j);
                }
                 //线程执行到这里阻塞,计数器减1,直到计数器减为0,----即这100个 线程都打印完毕才能执行await之后的代码,跟join()方法阻塞类似,不过CountDownLatch更灵活
                cdl.countDown();
              
            }));
        }
        for (Thread th:list
             ) {
            th.start();
        }
        try {
            cdl.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("打印结束");
    }
}

```

> **CountDownLatch一个有用的属性是，它不要求调用countDown线程等待计数到达零之前继续，它只是阻止任何线程通过await
> ，直到所有线程可以通过。**
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/5ca48d61ed614b04a12db4ab613bb61a.png)
> 调整门闩数量为12 时,运行结果如下图

![在这里插入图片描述](https://img-blog.csdnimg.cn/d2f68a1a10ec48cebe81631b7394462c.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81NDA2MTMzMw==,size_16,color_FFFFFF,t_70)即,再第12个线程运行完毕之后就可以执行await()方法之后的了,

调整门闩数量为101时,运行结果如下图
![在这里插入图片描述](https://img-blog.csdnimg.cn/da01639f1c1f4595b0853f8ab1097565.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81NDA2MTMzMw==,size_16,color_FFFFFF,t_70)总结-----
 门闩当被减为0时才会执行,如果不是0
      门闩大于0(处于阻塞状态.比如有100个线程,但是有101个门闩),不执行await之后的代码,而是继续等待下一个线程将此门栓消耗掉,
      或者门闩不够用的情况下,再门闩数被减为0之可以执行await之后的代码,

### CountDownLatch的使用场景一
API中的典型使用场景----

> 使用情况：下面是一对类，其中一组工人线程使用两个倒计时闩锁：
>
> 第一个是启动信号，阻止任何工人继续工作，直到司机准备好让他们继续工作： 第二个是完成信号，允许驾驶员等待所有工人完成。

```java

 
 class Driver { // ...
   void main() throws InterruptedException {
     CountDownLatch startSignal = new CountDownLatch(1);
     CountDownLatch doneSignal = new CountDownLatch(N);

     for (int i = 0; i < N; ++i) // create and start threads
       new Thread(new Worker(startSignal, doneSignal)).start();

     doSomethingElse();            // don't let run yet
     startSignal.countDown();      // let all threads proceed
     doSomethingElse();
     doneSignal.await();           // wait for all to finish
   }
 }

 class Worker implements Runnable {
   private final CountDownLatch startSignal;
   private final CountDownLatch doneSignal;
   Worker(CountDownLatch startSignal, CountDownLatch doneSignal) {
     this.startSignal = startSignal;
     this.doneSignal = doneSignal;
   }
   public void run() {
     try {
       startSignal.await();
       doWork();
       doneSignal.countDown();
     } catch (InterruptedException ex) {} // return;
   }

   void doWork() { ... }
 }
```
### CountDownLatch的使用场景二
> 另一个典型的用法是将问题分为 N 部分，用执行该部分并在闩锁上倒计时的可运行部分描述每个部分，并将所有 Runnable
> 排队到执行者。当所有子部件完成时，协调线程将能够通过等待。（当线程必须以这种方式反复倒计时时，请改为使用 CyclicBarrier。

 

```java
 class Driver2 { // ...
   void main() throws InterruptedException {
     CountDownLatch doneSignal = new CountDownLatch(N);
     Executor e = ...

     for (int i = 0; i < N; ++i) // create and start threads
       e.execute(new WorkerRunnable(doneSignal, i));

     doneSignal.await();           // wait for all to finish
   }
 }

 class WorkerRunnable implements Runnable {
   private final CountDownLatch doneSignal;
   private final int i;
   WorkerRunnable(CountDownLatch doneSignal, int i) {
     this.doneSignal = doneSignal;
     this.i = i;
   }
   public void run() {
     try {
       doWork(i);
       doneSignal.countDown();
     } catch (InterruptedException ex) {} // return;
   }

   void doWork() { ... }
 }
```

内存一致性效应：在计数达到零之前，在呼叫之前的螺纹中的操作-从另一个线程中的对应结果成功返回后发生的操作。countDown()await()

## 方式五--CyclicBarrier阻塞  

CyclicBarrier的使用方法就是使用计数器完毕后能重置为初始值;
简单的理解就是 必须要满足(拼团)指定数量的线程才可以执行,否则不满足的团不能执行而处于阻塞状态;

```java

import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;

/**
 * @author : Gavin
 * @date: 2021/8/21 - 08 - 21 - 13:01
 * @Description: ReviewDay
 * @version: 1.0
 */

public class CyclicBarrierTest {
  static  CyclicBarrier clb= new CyclicBarrier(20, new Runnable() {
        @Override
        public void run() {
            System.out.println("满员了-----可以发车");
        }
    });
   static  class Passenger extends Thread{
        private  String name;
        public Passenger(String name) {
            this.name = name;
        }

        @Override
        public void run() {
            System.out.println(name+"已上车");
            try {
                clb.await();
            } catch (InterruptedException e) {
                e.printStackTrace();
            } catch (BrokenBarrierException e) {
                e.printStackTrace();
            }
        }
    }
    public static void main(String[] args) {
       /*假设有48个人去旅游,而一辆中型大巴车只能坐20个人(包括司机在内)
       而客运站为了节约成本,规定不满员不发车
        */

        for (int i = 0; i < 48; i++) {//48个乘客
            new Thread(new Passenger("Per"+i)).start();
        }
    }
}

```
运行结果---
![在这里插入图片描述](https://img-blog.csdnimg.cn/5658811f56ee422aa1ca2de7cf295c41.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81NDA2MTMzMw==,size_16,color_FFFFFF,t_70)
### CyclicBarrier的使用场景
api中的典型案例-----
```java
class Solver {
   final int N;
   final float[][] data;
   final CyclicBarrier barrier;

   class Worker implements Runnable {
     int myRow;
     Worker(int row) { myRow = row; }
     public void run() {
       while (!done()) {
         processRow(myRow);

         try {
           barrier.await();
         } catch (InterruptedException ex) {
           return;
         } catch (BrokenBarrierException ex) {
           return;
         }
       }
     }
   }

   public Solver(float[][] matrix) {
     data = matrix;
     N = matrix.length;
     Runnable barrierAction =
       new Runnable() { public void run() { mergeRows(...); }};
     barrier = new CyclicBarrier(N, barrierAction);

     List<Thread> threads = new ArrayList<Thread>(N);
     for (int i = 0; i < N; i++) {
       Thread thread = new Thread(new Worker(i));
       threads.add(thread);
       thread.start();
     }

     // wait until done
     for (Thread thread : threads)
       thread.join();
   }
 }
```

> 在这里，每个工人线程处理一排矩阵，然后在障碍处等待，直到所有行都得到处理。当处理所有行时，将执行所提供的可运行障碍操作并合并行。如果合并确定已找到解决方案，则将返回，每个员工将终止。done()true
> 如果障碍操作不依赖于执行时暂停的当事方，则当当执行方的任何线程可以执行该操作时，该操作被释放。为了促进这一点，每次调用await()
> 返回该线程在障碍的到达指数。然后，您可以选择应执行"障碍"操作的线程，例如：
>
>    if (barrier.await() == 0) {    // log the completion of this
> iteration  }
> 该工具使用全或无中断模型进行失败的同步尝试：如果线程中断、故障或超时而过早离开障碍点，则在该障碍点等待的所有其他线程也会通过" BrokenBarrierException (or InterruptedException而离开 （或如果该扰动也在同一时间中断，则中断例外）

## 方式六--Phaser阻塞

phaser像是CountDownLatch和CyclicBarrier的结合体,

简单来说就是 如果一个工作需要分几个阶段完成,但是并不是所有人都要全程参与----
临近年关了,某公司要开会商讨一下今年年底的任务该怎么完成
会议分为好几个阶段
第一阶段是全体启动大会----QDmeeting()
第二阶段是领导商讨大会---LDmeeting()
第三阶段是高管研讨大会----GGmeeting()
第四阶段是董事投票决策-----DsDmeeting()
显然并不是所有员工都能全程参与会议

```java

import java.util.concurrent.Phaser;
import java.util.concurrent.TimeUnit;

class Person implements Runnable{
    static JoinMeeting jm=new JoinMeeting();
    private String name;
    private String work;
static void meetingTime(int time){
    try {
        TimeUnit.MILLISECONDS.sleep(time);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}

    public Person(String name, String work) {
        this.name = name;
        this.work = work;
    }

    public String getName() {
        return name;
    }


    public void setName(String name) {
        this.name = name;
    }

    public String getWork() {
        return work;
    }

    public void setWork(String work) {
        this.work = work;
    }

    public void QDmeeting(){
        meetingTime(100);
        System.out.printf("%s 参加了全员启动大会\n",name);

        jm.arriveAndAwaitAdvance();
    }

    public void LDmeeting(){

if(!(this.getWork().equals("员工"))){
    meetingTime(1000);
    System.out.printf("%s 参加了领导商讨大会\n",name);

    jm.arriveAndAwaitAdvance();
}

    }
    public  void GGmeeting(){

if((this.getWork().equals("高管")|this.getWork().equals("董事"))){
    meetingTime(2000);
    System.out.printf("%s 参加了高管研讨投票大会\n",name);

    jm.arriveAndAwaitAdvance();

}

    }

    public  void Dsmeeting(){

    if (this.getWork().equals("董事")){
        meetingTime(2000);
        System.out.printf("%s 参加了董事投票大会\n",name);
        jm.arriveAndAwaitAdvance();
    }
   else{
        jm.arriveAndDeregister();
   }
    }
    @Override
    public void run() {
QDmeeting();
LDmeeting();
GGmeeting();
Dsmeeting();
    }
}
class JoinMeeting extends Phaser{
    @Override
    protected boolean onAdvance(int phase, int registeredParties) {
        switch (phase){
            case 0:
                System.out.println("所有人都参加了全体启动大会,总共----"+registeredParties+"人");
                return false;
            case 1:
                System.out.println("所有领导都参加了领导商讨会议,总共----"+registeredParties+"人");
                return false;
            case 2:
                System.out.println("所有高管都参加了高管董事研讨投票会议,总共----"+registeredParties+"人");
                return false;
            case 3:
                System.out.println("所有董事参与了董事投票,总共----"+registeredParties+"人");
                return false;
            default :
              return true;
        }

    }


}

public class PhaserTest01 {
    public static void main(String[] args) {
        //公司总共35个人,20个基层员工,7个基层领导,5个高管,3个董事
        //注册员工数---
        Person.jm.bulkRegister(35);
        //开启线程
        //基层员工20人
        for (int i = 0; i <35 ; i++) {
            if(i<20){
            new Thread(new Person("WorkerPer"+i,"员工")).start();
            }else if(i<27){
            new Thread(new Person("JLeaderPer"+i,"领导")).start();
            }else if(i<33){
            new Thread(new Person("GLeaderPer"+i,"高管")).start();
           }
            else{
                new Thread(new Person("DLeaderPer"+i,"董事")).start();
            }
        }
    }
}

```
![在这里插入图片描述](https://img-blog.csdnimg.cn/373bc9805e5e440c846fd144a7bad4d5.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81NDA2MTMzMw==,size_16,color_FFFFFF,t_70)
### Phaser的使用场景典型应用场景--

API中给出的--

> 可用于控制为可变数量的当事方提供服务的一次性操作。典型的是用于将此设置为先注册，然后开始操作，然后取消注册的方法，如下所述：PhaserCountDownLatch

```java
 void runTasks(List<Runnable> tasks) {
   final Phaser phaser = new Phaser(1); // "1" to register self
   // create and start threads
   for (final Runnable task : tasks) {
     phaser.register();
     new Thread() {
       public void run() {
         phaser.arriveAndAwaitAdvance(); // await all creation
         task.run();
       }
     }.start();
   }

   // allow threads to start and deregister self
   phaser.arriveAndDeregister();
 }
//导致一组线程重复执行给定次数迭代的操作的一种方法是覆盖：onAdvance

 
 void startTasks(List<Runnable> tasks, final int iterations) {
   final Phaser phaser = new Phaser() {
     protected boolean onAdvance(int phase, int registeredParties) {
       return phase >= iterations || registeredParties == 0;
     }
   };
   phaser.register();//注册
   for (final Runnable task : tasks) {
     phaser.register();//注册
     new Thread() {
       public void run() {
         do {
           task.run();
           phaser.arriveAndAwaitAdvance();
         } while (!phaser.isTerminated());
       }
     }.start();
   }
   phaser.arriveAndDeregister(); // deregister self, don't wait
 }
//如果主要任务以后必须等待终止，则可以重新注册，然后执行类似的循环：
 
   // ...
   phaser.register();
   while (!phaser.isTerminated())
     phaser.arriveAndAwaitAdvance();
//相关结构可用于等待特定的相号，在您确信该阶段永远不会结束的情况下。例//如：Integer.MAX_VALUE

 
 void awaitPhase(Phaser phaser, int phase) {
   int p = phaser.register(); // assumes caller not already registered
   while (p < phase) {
     if (phaser.isTerminated())
       // ... deal with unexpected termination
     else
       p = phaser.arriveAndAwaitAdvance();
   }
   phaser.arriveAndDeregister();
 }
/*要使用相位器树创建一组任务，您可以使用以下形式的代码，假设任务类与构造器接受其在构建时注册的任务类。调用后，这些任务可以开始，例如提交到池中：nPhaserbuild(new Task[n], 0, n, new Phaser())

 
 void build(Task[] tasks, int lo, int hi, Phaser ph) {
   if (hi - lo > TASKS_PER_PHASER) {
     for (int i = lo; i < hi; i += TASKS_PER_PHASER) {
       int j = Math.min(i + TASKS_PER_PHASER, hi);
       build(tasks, i, j, new Phaser(ph));
     }
   } else {
     for (int i = lo; i < hi; ++i)
       tasks[i] = new Task(ph);
       // assumes new Task(ph) performs ph.register()
   }
 }*/
```

**最多人数限制为65535人。尝试注册额外的当事方导致。但是，您可以而且应该创建分层相位器，以容纳任意大组的参与者**

由此会衍生出分布式锁------将线程分组来完成对线程的控制
[分布式锁的几种实现方式](https://www.cnblogs.com/austinspark-jessylu/p/8043726.html)


## 方式七--ReadWriteLock阻塞  

顾名思义,读写锁---

```java

import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

/**
 * @author : Gavin
 * @date: 2021/8/21 - 08 - 21 - 19:39
 * @Description: ReviewDay
 * @version: 1.0
 */

//读写锁
    class ReadThread implements Runnable{//准备读线程
        Lock lock= new ReentrantLock(true);
    ReadWriteLock rwLock=new ReentrantReadWriteLock();
Lock readLock=rwLock.readLock();
     static void ReadTime(int time){
            try {
                TimeUnit.MILLISECONDS.sleep(time);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        //准备要读的内容
    static String book="平凡的世界";
//准备读方法
    //读的时候加锁
    public void ReadFunction(Lock lock){
        lock.lock();//加一把普通锁
        //模拟读取时间
        ReadTime(100);
        System.out.println("读取的值为--"+book);
        lock.unlock();
    }
    @Override
    public void run() {
ReadFunction(readLock);
    }
}

class WriteThread implements Runnable{
        //准备写锁
        Lock lock= new ReentrantLock(true);
       ReadWriteLock rwLock=new ReentrantReadWriteLock();
       Lock writeLock=rwLock.writeLock();
    static void WriteTime(int time){
        try {
            TimeUnit.MILLISECONDS.sleep(time);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
    //准备写方法
    public void writeFunction(Lock lock ,String str){
        lock.lock();
        WriteTime(1000);
        ReadThread.book=str;//写入数据
        System.out.println("写入的数据为----"+ReadThread.book);
        lock.unlock();
    }
    @Override
    public void run() {
     writeFunction(writeLock,"没时间迷茫了");
    }
}
public class ReadWriteLockTest01 {
    public static void main(String[] args) {
//开始启动线程了
        for (int i = 0; i < 5; i++) {
            new Thread(new ReadThread()).start();
        }
        for (int i = 0; i < 5; i++) {
            new Thread(new WriteThread()).start();
        }
    }
}

```

类的基本信息---
Interface ReadWriteLock

所有已知实现类： 
ReentrantReadWriteLock 

public interface ReadWriteLock,所以要借助子类来进行实例化;

> **读写锁允许在访问共享数据时比相互排除锁允许的并发级别更高**。它利用了这样一个事实，即虽然一次**只有一个线程**（编写器线程）可以**修改共享数据**，但在许多情况下，**任意数量的线程**可以**同时读取数据**（因此读取器线程）。从理论上讲，使用**读**写锁允许的并发性增加将导致**性能**比使用互排除锁有所**提高**。实际上，这种并发性增加只有在**多处理器上**才能完全实现，然后只有**当共享数据的访问模式**是合适的


关于读写锁的效率与普通锁的效率对比再下面这篇文章中以给出,详情点击连接
[可重入锁与读写锁的效率对比](https://blog.csdn.net/weixin_54061333/article/details/119794958)

### 读写锁的应用场景考量维度----
API中给出了以下几种
虽然读写锁的基本操作是直截了当的，但执行必须做出许多政策决策，这可能会影响特定应用中读写锁的有效性。这些政策的例子包括：

1,当**读者**和**作者**都在**等待**时，确定是**授予阅读锁**还是**写作锁**，当作者释放书写锁时。作家偏好是常见的，因为写作应该是短的和不频繁的。读者偏好并不常见，因为如果读者经常如预期的那样频繁且寿命长，则可能导致写作出现长时间的延迟。公平或"有序"实施也是可能的。
确定在读者活跃且作者等待时请求阅读锁的读者是否被授予阅读锁。对读者的偏好可以无限期地延迟编写器，而对作者的偏好可以降低并发的可能性。
确定锁是否重新进入：带书写锁的线程能否重新获得它？它能否在握住书写锁时获得读锁？读锁本身是否重新进入？
在不允许干预作者的情况下，写锁可以降级为读锁吗？阅读锁可以升级为书写锁，而不是其他等待的读者或作家？

### ReadWriteLock接口的实现类---
public class ReentrantReadWriteLock extends Object implements ReadWriteLock, Serializable
#### ReadWriteLock锁的特点
**重新进入**------可重入
此锁允许**读者和作家重新获得读或写锁的重新进入锁**的风格。在已发布所有由书写线程持有的写作锁之前，不允许非注册读者阅读。

> 此外，编写者可以获取读锁，但反之亦然。在其他应用程序中，当在呼叫期间或回调到在读取锁下执行读取的方法时，重新进入可能很有用。如果读者试图获得书写锁，它永远不会成功。

**锁定降级**------**书写锁可以降级为读锁,但是读锁不可以升级为书写锁**

重入还允许从**书写锁降级到读锁**，通过获取书写锁，然后读锁，然后释放书写锁。但是，无法从读锁升级为书写锁。

**中断锁定获取**  -------**支持锁中断**
读锁和写锁在锁定获取过程中都支持中断。

**条件支持**
写锁提供了一个条件实现，其行为方式与重入锁相同的方式，如重入锁提供的条件实现。当然，此条件只能与书写锁一起使用。

**读锁不支持条件和投掷。**

readLock().newCondition()UnsupportedOperationException

### ReadWriteLock的使用场景典型应用场景--
读写锁的应用案例----API
```java
 
 class CachedData {
   Object data;
   volatile boolean cacheValid;
   final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();

   void processCachedData() {
     rwl.readLock().lock();
     if (!cacheValid) {
       // Must release read lock before acquiring write lock
       rwl.readLock().unlock();
       rwl.writeLock().lock();
       try {
         // Recheck state because another thread might have
         // acquired write lock and changed state before we did.
         if (!cacheValid) {
           data = ...
           cacheValid = true;
         }
         // Downgrade by acquiring read lock before releasing write lock
         rwl.readLock().lock();
       } finally {
         rwl.writeLock().unlock(); // Unlock write, still hold read
       }
     }

     try {
       use(data);
     } finally {
       rwl.readLock().unlock();
     }
   }
 }
/*重新进入阅读阅读时钟可用于**提高**某些类型的集合的**某些用途的并发性**。这通常只有在集合预计很大、**访问读者线程多于编写器线程**、并且需要**操作的开销超过同步开销时**才值得。例如，下面是使用 TreeMap 的类，该类预计会很大且同时访问。*/
 
 class RWDictionary {
   private final Map<String, Data> m = new TreeMap<String, Data>();
   private final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();
   private final Lock r = rwl.readLock();
   private final Lock w = rwl.writeLock();

   public Data get(String key) {
     r.lock();
     try { return m.get(key); }
     finally { r.unlock(); }
   }
   public String[] allKeys() {
     r.lock();
     try { return m.keySet().toArray(); }
     finally { r.unlock(); }
   }
   public Data put(String key, Data value) {
     w.lock();
     try { return m.put(key, value); }
     finally { w.unlock(); }
   }
   public void clear() {
     w.lock();
     try { m.clear(); }
     finally { w.unlock(); }
   }
 }
/***实施说明
此锁最多支持 65535 递归写锁和 65535 读取锁。试图超过这些限制会导致锁定方法导致错误投掷。***/
```
![在这里插入图片描述](https://img-blog.csdnimg.cn/526443099a4b45b9a4e4711f35d7ac64.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81NDA2MTMzMw==,size_16,color_FFFFFF,t_70)




## 方式八--Exchanger阻塞  

exchanger是一个简单的两个线程交换信息的类,exchanger要是两个线程用的同一个对象

```java
import java.util.concurrent.Exchanger;
class Miejueshitai implements Runnable{

 static final  Exchanger<String> exchanger= new Exchanger<>();
    public  Exchanger<String> getExchanger() {
        return exchanger;
    }
    private String Knife="倚天剑";
    @Override
    public void run() {
        try {
            Thread.sleep(1000);
            Knife=exchanger.exchange(Knife);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("拿倚天剑换"+Knife);
    }
}
class Zhangwuji implements Runnable{
    private  String Knife="屠龙宝刀";
    @Override
    public void run() {
        try {
            Thread.sleep(1000);
            Knife=Miejueshitai.exchanger.exchange(Knife);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("拿屠龙刀换"+Knife);
    }
}
public class ExchangerTest01 {
    public static void main(String[] args) {
        new Thread(new Miejueshitai()).start();
        new Thread(new Zhangwuji()).start();
    }
}
```

不写了,直接看以前的吧..............
[一个简单的顾名思义类-----Exchanger的应用](https://blog.csdn.net/weixin_54061333/article/details/119831020)

## 方式九--LockSupport阻塞  
LockSupport跟Lock的子类ReentrantLock.synchronized一样都属于锁的范畴

简单回顾一下他们的不同点------
1,synchronized,是一个关键字,系统自动加锁,解锁,不可以出现多个不同的等待队列,默认是进行四种锁的状态升级;
2,Lock的子类---ReentrantLock,需要手动加锁解锁,还可以用Lock不同的子类对象完成不同的操作;

LockSupport 实现的线程阻塞相对来说比较灵活

```java

import java.util.concurrent.locks.LockSupport;
public class LockSupportTest01 {
    public static void main(String[] args) {
        new Thread(()->{
            for (int i = 0; i < 10; i++) {
                if(i==8){
                 LockSupport.park();//阻塞线程
                }
                System.out.println("打印---"+i);
            }
        }).start();
    }
}

```
![在这里插入图片描述](https://img-blog.csdnimg.cn/1b3cce98b1564a3784d9a8a2cde0d765.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81NDA2MTMzMw==,size_16,color_FFFFFF,t_70)

```java

import java.util.concurrent.locks.LockSupport;
public class LockSupportTest01 {
    public static void main(String[] args) {
        new Thread(()->{
            for (int i = 0; i < 10; i++) {
                if(i==8){
                 LockSupport.park();//阻塞线程
                }
                System.out.println("打印---"+i);
                LockSupport.unpark(Thread.currentThread());
            }
        }).start();
    }
}
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/6598708dd8ba44c9a4cb0d21baa167bb.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81NDA2MTMzMw==,size_16,color_FFFFFF,t_70)如果没有指定要阻塞的线程,则默认为当前线程;

**unpark()方法的优先级高于park()**

如果一个线程被阻塞后唤醒,之后又被阻塞了,那么这个线程就无法在被唤醒了,会一直处于阻塞状态

```java
package ReviewDay;

import java.util.concurrent.locks.LockSupport;
public class LockSupportTest01 {
    public static void main(String[] args) {
       Thread t= new Thread(new Runnable() {
           @Override
           public void run() {
               for (int i = 0; i < 20; i++) {

                   if(i==6){
                       LockSupport.park();
                   }
                   System.out.println("打印---"+i);
                    if(i==18){
                         LockSupport.park();
                        }
               }
           }
       });
       t.start();
        LockSupport.unpark(t);
        LockSupport.unpark(t);
    }
}

```
![在这里插入图片描述](https://img-blog.csdnimg.cn/4ef1119ed9d74fe482069b72960dcc6c.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81NDA2MTMzMw==,size_16,color_FFFFFF,t_70)
总结----
1,由此可以发现LockSupport不需要像wait()方法那样需要同步代码来进行阻塞,而是任何时候想要阻塞就可以阻塞;
2,unpark()优先级高于park()-----源自于jvm底层指令重排;
3,若一个线程被阻塞两次,那么该线程就一直处于阻塞状态,无法被唤醒了;



## 方式十--Semaphore阻塞  
Semaphore
```java

public class SemaphoreTest01 {
    public static void main(String[] args) {
        Semaphore sp= new Semaphore(2,true);
        Thread []threads = new Thread[4];
        for (int i = 0; i < 4; i++) {
            threads[i]= new Thread(new Runnable() {
                @Override
                public void run() {

                    try {
                        sp.acquire();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println("T-start");
                    try {
                        Thread.sleep(2000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println("T-end");
                    sp.release();
                }
            });
        }
        for (Thread th :
                threads) {
            th.start();
        }
    }
}

```
![在这里插入图片描述](https://img-blog.csdnimg.cn/8c8621d1593d44a1aba3568d1b53b3d3.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81NDA2MTMzMw==,size_16,color_FFFFFF,t_70)



> 昨天在写一个面试题的时候,发现线程中断哪里还有些不太明白的地方,今日特地来整理以下;


# 线程中断

> 中断（Interrupt）一个线程意味着在该线程完成任务之前停止其正在进行的一切，有效地中止其当前的操作。
> 线程是死亡、还是等待新的任务或是继续运行至下一步，就取决于这个程序。


在java中一般使用stop()方法来强制中断程序的运行,而建议用Interrupt(中断)来完成对当前操作的中止;
java中关于Interrupt的几种方法------
![在这里插入图片描述](https://img-blog.csdnimg.cn/6b0ae995055740f984e7f64d59864acd.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_Q1NETiBAR2F2aW5fTGlt,size_76,color_FFFFFF,t_70,g_se,x_16)

> 除非**当前线程中断自身**，这是始终允许的，所以调用此线程的checkAccess方法，这可能会导致抛出SecurityException
>
>
> 如果该线程**阻塞**的调用**wait() ， wait(long) ，或wait(long,
> int)的方法Object类，或者在join() ， join(long) ， join(long, int) ， sleep(long) ，或sleep(long, int)这个类的方法，那么**它的中断状态将被清除**，并且将收到一个InterruptedException 。 
>
> 如果该线程在可阻止在I / O操作InterruptibleChannel则信道将被关闭，该线程的中断状态将被设置，并且线程将收到一个ClosedByInterruptException。 
>
> 如果该线程在Selector中被阻塞，则线程的中断状态将被设置，并且它将从选择操作立即返回，可能具有非零值，就像调用了选择器的wakeup方法一样。
>
>
> 如果以前的条件都不成立，则该线程的中断状态将被设置。 
>
> 中断不存在的线程不需要任何效果。

![在这里插入图片描述](https://img-blog.csdnimg.cn/ca09db778edb440c8830c8f14fb1fc93.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_Q1NETiBAR2F2aW5fTGlt,size_78,color_FFFFFF,t_70,g_se,x_16)
![在这里插入图片描述](https://img-blog.csdnimg.cn/0a957b1f8ed44c59a718b8a3245cf5f7.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_Q1NETiBAR2F2aW5fTGlt,size_78,color_FFFFFF,t_70,g_se,x_16)![在这里插入图片描述](https://img-blog.csdnimg.cn/5f170264af774015afa786aedaf457dd.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_Q1NETiBAR2F2aW5fTGlt,size_69,color_FFFFFF,t_70,g_se,x_16)



首先从线程的生命周期入手-----

JAVA把线程分为  NEW     RUNNABLE     TERMINATED 三个阶段,其中 RUNNABLE阶段又可以分为
 BLOCKED(阻塞)
 WAITING(无限期等待)
 TIMED_WAITING(有限期等待)

## NEW 与TERMINATED阶段

```java

class xc extends Thread {
    @Override
    public void run() {
        for (int i = 0; i < 10; i++) {
            if (i == 5)  Thread.currentThread().interrupt();//当前线程中断标记
            if(Thread.currentThread().isInterrupted()){
               break;
            }
            System.out.println("打印----" + i);
        }
    }
}
public class InterruptedTest {
    public static void main(String[] args) {
       Thread t=new xc();
        System.out.println(t.getState());//NEW
        t.interrupt();
        System.out.println("t还活着吗---"+t.isAlive());//false
        System.out.println("t被中断了吗---"+t.isInterrupted());//true
    }
}


```
NEW阶段中断线程没有任何意义,因为该线程从来就没有活过,虽然被标记为中断状态;

```java

class xc extends Thread {
    @Override
    public void run() {
        for (int i = 0; i < 10; i++) {
            /*if (i == 5)  Thread.currentThread().interrupt();//当前线程中断标记
            if(Thread.currentThread().isInterrupted()){
               break;
            }*/
            System.out.println("打印----" + i);
        }

    }
}
public class InterruptedTest {
    public static void main(String[] args) {
       Thread t=new xc();
        System.out.println(t.getState());//NEW
       t.start();
        System.out.println(t.getState());//RUNNABLE
        try {
            t.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(t.getState());//TERMINATED
        t.interrupt();

        System.out.println("t被中断了吗---"+t.isInterrupted());//true
         System.out.println("t还活着吗---"+t.isAlive());//false
    }
}

```
TERMINATED阶段中断线程也没有任何意义,因为该线程已经运行完了,虽然被标记为中断状态;


## RUNNABLE阶段
#### 非阻塞阶段
```java

class xc extends Thread {
    @Override
    public void run() {
        for (int i = 0; i < 10; i++) {
            if (i == 5) {
                //可以根据需要来选择中断线程
              if(Thread.currentThread().isInterrupted()){//检测是否有中断的标记
                  return;//结束
              }
            }
            System.out.println("打印----" + i);
        }
        System.out.println("我是for循环之外的代码");
    }
}
public class wertyu {
    public static void main(String[] args) {
        Thread t=new xc();
        t.start();
        t.interrupt();//设置线程为中断状态
    }
}
```
![在这里插入图片描述](https://img-blog.csdnimg.cn/c09f9e0b0747478e8ee600dcbf7fb023.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAR2F2aW5fTGlt,size_20,color_FFFFFF,t_70,g_se,x_16)
#### 阻塞阶段

> 如果该线程**阻塞**    即调用**wait() ， wait(long) ，或wait(long,
> int)的方法Object类，或者在join() ， join(long) ， join(long, int) ， sleep(long) ，或sleep(long, int)这个类的方法，那么**它的中断状态将被清除**，并且将收到一个InterruptedException 。 

```java

class xc extends Thread {
    @Override
    public void run() {
        for (int i = 0; i < 10; i++) {
            try {
                Thread.currentThread().sleep(100);
            } catch (InterruptedException e) {
                System.out.println("线程中断异常-------");
            }
            System.out.println("打印----" + i);
            //可以根据需要来选择中断线程
             // if(Thread.currentThread().isInterrupted()){//检测是否有中断的标记
                  //return;//结束
            //  }


        }
        System.out.println("我是for循环之外的代码");
    }
}
public class wertyu {
    public static void main(String[] args) {
        Thread t=new xc();
        t.start();
        t.interrupt();//设置线程为中断状态
    }
}
```
![在这里插入图片描述](https://img-blog.csdnimg.cn/6c9ab44224214f0da5fd92f22e30e601.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAR2F2aW5fTGlt,size_20,color_FFFFFF,t_70,g_se,x_16)




>  由上面代码可以发现当某线程调用了interrupt()方法时只是将当前线程标记为中断但实际并没有结束运行;需要一些其他判断来真正完成该线程的中断;

 

```java


class xc extends Thread {
    @Override
    public void run() {
        for (int i = 0; i < 10; i++) {
            System.out.println("打印----" + i);
            try {
                Thread.currentThread().sleep(100);
            } catch (InterruptedException e) {
                System.out.println("线程中断异常-------");
                //可以根据需要来选择中断线程
                if(!(Thread.currentThread().isInterrupted())){//检测是否有中断的标记
                    return;//结束
                }
            }
        }
        System.out.println("我是for循环之外的代码");
    }
}
public class wertyu {
    public static void main(String[] args) {
        Thread t=new xc();
        t.start();
        t.interrupt();//设置线程为中断状态
    }
}

```
![在这里插入图片描述](https://img-blog.csdnimg.cn/11f543e13a59470092b0b29205e7e313.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAR2F2aW5fTGlt,size_20,color_FFFFFF,t_70,g_se,x_16)**中断阻塞状态后会将线程的阻塞状态标记重置为false,所以在Thread.currentThread().isInterrupted()的结果会返回false,要取反,**

看一下如果不取反的情况下-----结果

![在这里插入图片描述](https://img-blog.csdnimg.cn/9a1513b39ea94cf08f307f00c8ff2e03.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAR2F2aW5fTGlt,size_20,color_FFFFFF,t_70,g_se,x_16)
案例应用-----只希望打印0-5,之后线程中断-----

```java
class xc extends Thread {
    @Override
    public void run() {
        for (int i = 0; i < 10; i++) {
            System.out.println("打印----" + i);
            if (i == 5) {
                if (!(Thread.currentThread().isInterrupted())) {//检测是否有中断的标记
                    return;//结束
                }
            }
        }
        System.out.println("我是for循环之外的代码");
    }

}

public class wertyu {
    public static void main(String[] args) {
        Thread t = new xc();
        t.start();
        try {
            Thread.sleep(1000);//睡一秒
        } catch (InterruptedException e) {
            System.out.println("线程中断异常-------");
        }
        t.interrupt();//设置线程为中断状态

    }
}
```
![在这里插入图片描述](https://img-blog.csdnimg.cn/cdb06b5da41148bb91c62b17182b11cb.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAR2F2aW5fTGlt,size_20,color_FFFFFF,t_70,g_se,x_16)
于是就衍生出了一道面试题--------


# 线程面试题

> 实现一个容器,提供两个方法,add和size,写两个线程,  *               
>  线程1添加10个元素到容器,  * 
> 线程2负责监控元素个数,当个数达到5个时,线程2给出提示并结束



>  分析----ThinkTwice CodeOnce  * 
>  线程2发出的动作是让线程1停止,而不是线程1自己停止,
>  即线程2在线程1添加元素为第五个之前一直处于阻塞状态  ,因为一直要监控容器的容量*    

怎么才能阻塞?  *  
>   // 同步方法  用synchronized.配合wait().notify() ,  * 
>   用lock.lock(),或者 lock.unlock()来手动释放锁  *    
>   而且线程1跟线程2必须用的是同一把锁,不然不会得到想要的结果;  *    

 线程1,线程2启动的顺序分析-------

> 元素个数为5之前线程1直持有该锁,要么线程2拿不到该锁要么线程2故意谦让给有需要的线程1但是线程2是一直要监控的容器容量的,所以线程2要先启动,但是线程2在容量为5之前用不到该锁,线程1在容量为5之后也用不到该锁了,所以协商一下各自取得锁的时间;各取所需;


## 代码实现
### 方式一--synchronized
```java

import java.util.ArrayList;
import java.util.List;


/**
 * @author : Gavin
 * @date: 2021/8/22 - 08 - 22 - 10:25
 * @Description: 面试问题实现一个容器,提供两个方法,add和size,写两个线程,
 *                线程1添加10个元素到容器,
 *                线程2负责监控元素个数,当个数达到5个时,线程2给出提示并结束
 */
public class TBMT {
    //准备容器
  static   List list= new ArrayList();
  //添加元素的方法
public static void add(Object obj){
    list.add(obj);
}
//监控容器大小的方法
public static int size(){
    return list.size();
}
    //准备一把锁,----用synchronized方式实现
    final static TBMT TB=new TBMT();//
    public static void main(String[] args) {

        //开启线程,先开线程2
        new Thread(()->{
            //线程2要执行容器大小为5的时候进行操作,而不是5的时候处于阻塞状态
            synchronized (TB) {
                if (size() < 5) {
                    System.out.println("证明线程2启动了---");
                    try {
                        TB.wait();//容量小于5的时候锁等待,线程1可以拿到锁
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                } else {

                    TB.notify();//容量不小于5的时候锁唤醒
                }
                System.out.println("线程2结束了---");
            }
        },"线程2").start();


        new Thread(()->{
            //线程1要执行往容器中添加元素的操作(容量<=5时添加,大于5时不添加)

synchronized (TB) {
    //执行添加元素操作
    for (int i = 0; i < 5; i++) {
        if (size() < 5) {
            TB.notify();//容量小于5的时候锁唤醒
            add(new Object());
            System.out.println("线程1添加第--" + i + "个元素");
        } else {
            try {
                TB.wait();//容量不小于5的时候锁等待,这时候线程2可以拿到锁了
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
        },"线程1").start();
    }
}

```

### 方式二--Lock与LockSupport

```java
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.LockSupport;
import java.util.concurrent.locks.ReentrantLock;


public class TBMTlock {
    //准备容器
    static List list = new ArrayList();

    //添加元素的方法
    public static void add(Object obj) {
        list.add(obj);
    }

    //监控容器大小的方法
    public static int size() {
        return list.size();
    }

    //准备一把锁,----用synchronized方式实现
    final static TBMT TB = new TBMT();//
    final static Lock lock = new ReentrantLock();

    public static void main(String[] args) {
        //开启线程,先开线程2
        Thread t1 = new Thread(() -> {
            //线程2要执行容器大小为5的时候进行操作,而不是5的时候处于阻塞状态

            System.out.println("证明线程2启动了---");//执行这一句话
            lock.lock(); //一开始时线程2先拿到锁
            if ((size() < 5)) {
                lock.unlock();//如果size()小于5的时候 线程2先把锁释放让给线程1
            }
            LockSupport.park();//接着线程2进入阻塞状态
            //等得被唤醒后继续操作
            // 唤醒后第一件事拿锁
            System.out.println("线程2结束了---");
        }, "线程2");
        
        Thread t2 = new Thread(() -> {
            //线程1要执行往容器中添加元素的操作(容量<=5时添加,大于5时不添加)
            //执行添加元素操作
            for (int i = 0; i < 10; i++) {
                if ((size() < 5)) {
                    lock.lock(); //容量小于5的时候能抢到线程2释放的锁
                    add(new Object());
                    System.out.println("线程1添加第--" + i + "个元素");
                } else {
                 lock.unlock();//容量不小于5的时候该释放锁了同时唤醒线程2
                    LockSupport.unpark(t1);
                }
            }
        }, "线程1");
        
        t1.start();
        t2.start();
    }
}

```
![在这里插入图片描述](https://img-blog.csdnimg.cn/4a4c73c068574e7da7ade5f14f9c781c.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81NDA2MTMzMw==,size_16,color_FFFFFF,t_70)
### 方式三--CountDownLatch与LockSupport
思路跟方式二差不多,只不过这次换成了计数器方式

```java

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CountDownLatch;

/**
 * @author : Gavin
 * @date: 2021/8/22 - 08 - 22 - 10:25
 * @Description: 实现一个容器, 提供两个方法, add和size, 写两个线程,
 * 线程1添加10个元素到容器,
 * 线程2负责监控元素个数,当个数达到5个时,线程2给出提示并结束
 * @version: 1.0
 * 分析----ThinkTwice CodeOnce
 * //线程2发出的动作是让线程1停止,而不是线程1自己停止,即线程2在线程1添加元素为第五个之前一直处于阻塞状态
 * //怎么才能阻塞?
 * // 同步方法  用synchronized. , 用lock.来手动释放锁
 * 而且线程1跟线程2必须用的是同一把锁,
 * 线程1启动,线程2启动,元素个数为5之前线程1直持有该锁,但是线程2是一直要监控的,所以线程2要先启动
 */


public class TBMST001 {
    //准备容器
    static List list = new ArrayList();
    //添加元素的方法
    public static void add(Object obj) {
        list.add(obj);
    }
    //监控容器大小的方法
    public static int size() {
        return list.size();
    }

    //准备一个计数器---公用的,----用CountDownLatch方式实现
   
    static CountDownLatch cdl=new CountDownLatch(1);

    public static void main(String[] args) {
        //准备一个计数器//就准备一个,且当size()小于5的时候在线程2中休眠,线程1中等于5的时候打开--即让线程1中止,
        //开启线程,先开线程2
        new Thread(() -> {
            //线程2要执行容器大小为5的时候进行操作,而不是5的时候处于阻塞状态
            //执行这一句话
            System.out.println("证明线程2启动了---");
            if ((size() < 5)) {
                try {
          cdl.await();//如果size()小于5的时候 线程2中先不做操作,计数器休眠,当计数器减为0的时候执行后续的代码
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            //等到计数器被减为0的时候,执行后续操作
            System.out.println("线程2结束了---");
        }, "线程2").start();

       new Thread(() -> {
            //线程1要执行往容器中添加元素的操作(容量<=5时添加,大于5时不添加)
            //执行添加元素操作
            for (int i = 0; i < 10; i++) {
                if ((size() < 5)) {
                    add(new Object());
                    System.out.println("线程1添加第--" + i + "个元素");
                } else {
                   cdl.countDown();

                }
            }

        }, "线程1").start();

    }
}

```
![在这里插入图片描述](https://img-blog.csdnimg.cn/98102e8152be4b45b752e049df41689a.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81NDA2MTMzMw==,size_16,color_FFFFFF,t_70)
实现方法有好多,可以将之前学过的线程阻塞方式融汇贯通,
各种阻塞方式已经整理好,请移步-----


[线程阻塞与唤醒](https://blog.csdn.net/weixin_54061333/article/details/119835674)

加油,努力,明天去面试,虽然与程序猿职位无关,担当下时养活自己最重要,还谈什么梦想.....

今天再来一种方式-----

```java
package ReviewDay;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.Semaphore;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.LockSupport;
import java.util.concurrent.locks.ReentrantLock;
public class TBMST01 {
    //准备容器
   static List list = new ArrayList();

    //添加元素的方法
    public static void add(Object obj) {
        list.add(obj);
    }
    //监控容器大小的方法
    public static int size() {
        return list.size();
    }
    //准备一把锁,----用synchronized方式实现
    final static TBMT TB = new TBMT();//
    final static Lock lock = new ReentrantLock();
    static Semaphore sp = new Semaphore(1);//只有一个许可证
    static Thread t1 = null;
    static Thread t2 = null;

    public static void main(String[] args) {
        //开启线程,先开线程2,开启线程2的时候线程1加进来
        t1 = new Thread(() -> {
            //线程1拿到许可证,先添加五个元素
            try {
                sp.acquire();
                for (int i = 0; i < 5; i++) {
                    add(new Object());
                    System.out.println("线程1添加了第" + i + "个元素");
                }
                //添加完毕之后释放令牌权限
                sp.release();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            //这个时候唤醒线程2了,
            LockSupport.unpark(t2);
            LockSupport.park();//线程1休眠
            //由于添加了一半,还需要添加另一半
            //获得权限
           try {
                sp.acquire();

               for (int i = 5; i < 10; i++) {
                   add(new Object());
                   System.out.println("线程1添加了第" + i + "个元素");
               }
               sp.release();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }


        }, "线程1");

        t2 = new Thread(() -> {
            try {
                sp.acquire();//一开始线程2拿到许可证
                //之后输出一句话
                System.out.println("线程2启动了---");
                sp.release();//下放许可证 ---之后线程1加进来
                t1.start();//启动线程1
                LockSupport.park();//线程2休眠了

            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            try {
                sp.acquire();
                System.out.println("线程2结束---");
                sp.release();
               
                    if (size() >= 5) {
                        System.exit(1);
                    }                               
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, "线程2");
       t2.start();
    }
}

```

但是这种有一个缺陷是当线程2运行完毕后,线程1还处于睡眠状态,强行中止的话.........     但请大佬能在这种情况下做一些改进;

改进方式如下------但是有弊端

```java

public class TBMST01 {
    //准备容器
    static List list = new ArrayList();

    //添加元素的方法
    public static void add(Object obj) {
        list.add(obj);
    }

    //监控容器大小的方法
    public static int size() {
        return list.size();
    }

    //准备一把锁,----用synchronized方式实现
    final static TBMT TB = new TBMT();//
    final static Lock lock = new ReentrantLock();
    static Semaphore sp = new Semaphore(1);//只有一个许可证
    static Thread t1 = null;
    static Thread t2 = null;

    public static void main(String[] args) {
        //开启线程,先开线程2,开启线程2的时候线程1加进来
        t1 = new Thread(() -> {
            //线程1拿到许可证,先添加五个元素
            try {

                sp.acquire();

                for (int i = 0; i < 5; i++) {

                    add(new Object());
                    System.out.println("线程1添加了第" + i + "个元素");

                }
                if (size() == 5) {
                    if ((Thread.currentThread().isInterrupted())) {
                        sp.release();
                        LockSupport.unpark(t2);
                        return;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }


            try {
                sp.acquire();
                for (int i = 5; i < 10; i++) {
                    add(new Object());
                    System.out.println("线程1添加了第" + i + "个元素");
                }
                sp.release();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }


        }, "线程1");

        t2 = new Thread(() -> {
            try {
                sp.acquire();//一开始线程2拿到许可证
                //之后输出一句话
                System.out.println("线程2启动了---");

                sp.release();//下放许可证 ---
                if (size() < 5) {
                    LockSupport.park();//线程2休眠了
                }

            } catch (InterruptedException e) {
                e.printStackTrace();
            }


            System.out.println("线程2结束---");


        }, "线程2");
        t2.start();
        t1.start();
        try {
            Thread.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        t1.interrupt();//标记为中断
    }
}

```
这种方式的弊端是
![在这里插入图片描述](https://img-blog.csdnimg.cn/db6432c9e69144039742abb72cfc36ce.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAR2F2aW5fTGlt,size_20,color_FFFFFF,t_70,g_se,x_16)

> 中断之前要睡一下,-----无论那个线程睡一下,目的是为了给添加5个元素留有时间,时间多了不行少了也不行,不太好控制;